λ > let returnAfterApply f a c = f a
Defined.

λ > returnAfterApply not True "Oden"
False

-- it is also the same as (.) const:

λ > :t [(.) const, returnAfterApply]
(a1 -> a) -> a1 -> b -> a]

λ > :t not
Bool -> Bool

λ > :t const
a -> b -> a

λ > :t flip const
flip const :: b -> c -> c

λ > :t const id
const id :: b -> c -> c

:t flip id
b -> (b -> c) -> c

id :: a -> a      -- including functions, so
a = (b -> c)
id :: (b -> c) -> (b -> c)
id :: (b -> c) -> b -> c    -- rewritten since right associative.

-- this can be interpreted as a function taking 2 arguments.
-- The first, of type b -> c and the second, of type b.
-- So these 2 arguments can be flipped:

flip :: (a -> b -> c) -> (b -> a -> c)
id :: (b -> c) -> b -> c
flip id :: b -> (b -> c) -> c
