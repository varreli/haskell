Aug 13 21:08:32 <crestfallen>	hi why wouldn't the following return [15]    ?  ..
Aug 13 21:08:42 <crestfallen>	> pure ((*3) 5)
Aug 13 21:08:45 <lambdabot>	 error:
Aug 13 21:08:45 <lambdabot>	     • Ambiguous type variable ‘f0’ arising from a use of ‘show_M535413171008...
Aug 13 21:08:45 <lambdabot>	       prevents the constraint ‘(Show (f0 Integer))’ from being solved.
Aug 13 21:09:17 <crestfallen>	> pure ((*3) 5) :: Integer
Aug 13 21:09:19 <lambdabot>	 error:
Aug 13 21:09:19 <lambdabot>	     • Couldn't match expected type ‘Integer’
Aug 13 21:09:19 <lambdabot>	                   with actual type ‘f0 Integer’
Aug 13 21:09:38 <crestfallen>	weird the first try works in ghci
Aug 13 21:10:03 <crestfallen>	pure (*3) 5)  returns 15, not [15]
Aug 13 21:10:05 <mniip>	it does so in the IO applicative
Aug 13 21:10:08 <Axman6>	it'll be using f ~ IO in ghci
Aug 13 21:10:17 <mniip>	% pure ((*3) 5)
Aug 13 21:10:18 <yahb>	mniip: 15
Aug 13 21:10:30 <Axman6>	try pure ((*3) 5) :: [Integer]
Aug 13 21:11:03 <crestfallen>	so the list needs to be specified
Aug 13 21:11:06 <Axman6>	the type you're actually getting (which :t it should confirm) will be IO Integer
Aug 13 21:11:50 <crestfallen>	> pure ((*3) 5) :: [Integer]
Aug 13 21:11:51 <Axman6>	remembe rthat GHCi will execute IO actions
Aug 13 21:11:53 *	dfeuer has quit (Ping timeout: 268 seconds)
Aug 13 21:11:53 <lambdabot>	 [15]
Aug 13 21:12:08 *	flintice2 (~geno@190.146.124.155) has joined
Aug 13 21:12:34 *	nineonine has quit (Read error: Connection reset by peer)
Aug 13 21:12:40 <jle`>	crestfallen: remember that pure is an example of "return-type polymorphism", where the type of the return type of the function dictates which instance is dispatched
Aug 13 21:12:47 <jle`>	another common example is 'read'
Aug 13 21:12:51 <jle`>	> read "5" + 2
Aug 13 21:12:54 <lambdabot>	 7
Aug 13 21:12:57 <jle`>	> read "True" || False
Aug 13 21:13:00 <lambdabot>	 True
Aug 13 21:13:14 <mniip>	% let x = traceShow (typeOf x) $ pure 123 in x
Aug 13 21:13:14 <yahb>	mniip: IO Integer; 123
Aug 13 21:13:32 <jle`>	read is actually a bunch of different functions under the same name, and each type has a different implementation of read
Aug 13 21:13:42 <jle`>	so the return type determines which implementation to use
Aug 13 21:14:51 *	u0_a144` (~user@072-184-243-113.res.spectrum.com) has joined
Aug 13 21:14:52 <crestfallen>	ok so when we have a case where the return could be impure, we need to specify if we want a functor like [15], or Integer IO etc
Aug 13 21:15:47 <crestfallen>	or is IO also pure at that stage?
Aug 13 21:15:57 *	warsoul (~warsoul@unaffiliated/warsoul) has joined
Aug 13 21:16:00 *	warsoul (~warsoul@unaffiliated/warsoul) has left
Aug 13 21:16:36 *	CSP-SOFTWARE (~uwx@172.245.163.218) has joined
Aug 13 21:16:47 <jle`>	return is never impure
Aug 13 21:16:51 *	u0_a144 has quit (Ping timeout: 264 seconds)
Aug 13 21:16:53 <jle`>	er, pure is never 'impure'
Aug 13 21:16:54 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 21:17:21 <jle`>	in this case we have `pure :: Applicative f => a -> f a`, so the choice of 'f' (in the return type) determines which implementation of pure to use
Aug 13 21:17:35 <jle`>	so it's not really a pure/impure sort of distinction
Aug 13 21:18:05 *	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined
Aug 13 21:18:24 <crestfallen>	ok yeah your comment "the return type of the function dictates which instance is dispatched is helpful...
Aug 13 21:18:47 *	gienah has quit (Ping timeout: 245 seconds)
Aug 13 21:18:57 *	flintice2 has quit (Excess Flood)
Aug 13 21:19:13 <crestfallen>	so once again its a case where studying the type signature is KEY. thanks Axman6 mniip jle`   alot    also
Aug 13 21:19:25 <crestfallen>	..
Aug 13 21:20:03 *	jgt (~jgt@2a02:a31b:8542:b480:bcd3:ffda:9aec:4372) has joined
Aug 13 21:20:25 <crestfallen>	if you could look at my final draft of Sundays evaluation by hand..
Aug 13 21:20:52 *	nbloomf has quit (Quit: My MacBook has gone to sleep. ZZZzzz…)
Aug 13 21:20:52 <crestfallen>	to tell me if you'd do it differently.
Aug 13 21:21:58 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 21:22:19 <crestfallen>	https://paste.ee/p/go0ej   jle` et al
Aug 13 21:23:09 <jle`>	i wouldn't say "is sugar for", but rather "evaluates to"
Aug 13 21:23:26 <jle`>	just from the definition of <*>
Aug 13 21:23:31 <jle`>	for lists
Aug 13 21:23:37 *	gienah_ has quit (Ping timeout: 246 seconds)
Aug 13 21:23:54 <jle`>	if you want to be explicit with the evaluation, i think you do skip a few steps
Aug 13 21:24:11 *	Lycurgus (~niemand@98.4.103.219) has joined
Aug 13 21:26:07 <crestfallen>	I start on lines 11 and 24. where do I skip steps?
Aug 13 21:26:27 *	jgt has quit (Ping timeout: 264 seconds)
Aug 13 21:28:06 <crestfallen>	(I used sugar since you mentioned it sunday, though only for the (\x -> (\y z .. )    and used the term inner lambda
Aug 13 21:28:10 <crestfallen>	)
Aug 13 21:28:21 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 21:28:54 <jle`>	(\x y z -> ..) is sugar for (\x -> \y z -> ..), but the application of <*> is not sugar
Aug 13 21:29:11 <jle`>	well, the full steps to evaluating [f] <$> [1,2] <*> [3,4] <*> [5,6]
Aug 13 21:29:26 <jle`>	would probably be [f 1, f 2] <*> [3,4] <*> [5,6]
Aug 13 21:29:36 <jle`>	 = [f 1 3, f 1 4, f 2 3, f 2 4] <*> [5,6]
Aug 13 21:30:05 <jle`>	= [f 1 3 5, f 1 3 6, f 1 4 5, f 1 4 6, f 2 3 5, f 2 3 6, f 2 4 5, f 2 4 6]
Aug 13 21:31:17 *	gienah has quit (Ping timeout: 245 seconds)
Aug 13 21:31:49 <crestfallen>	ok so my evaluation order is actually wrong
Aug 13 21:31:50 <jle`>	i guess that does skip some steps within the implementation of <*>, however it is implemented
Aug 13 21:32:07 *	jusss has quit (Ping timeout: 245 seconds)
Aug 13 21:32:53 *	day__ (~Unknown@unaffiliated/day) has joined
Aug 13 21:33:02 *	fosterite (~fosterite@2601:445:447f:dd14:441a:5e8a:d6c2:4223) has joined
Aug 13 21:33:23 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 21:34:07 *	gienah_ has quit (Ping timeout: 246 seconds)
Aug 13 21:35:11 <crestfallen>	 [f 1 3, f 1 4, f 2 3, f 2 4]   << so here f 2 is evaluated first, before all 4 (f 1)'s are evaluated ?
Aug 13 21:35:33 *	ht_ (~Thunderbi@ip-213-127-90-232.ip.prioritytelecom.net) has joined
Aug 13 21:35:49 <jle`>	if we are talking about order of evaluation, it doesn't matter
Aug 13 21:35:59 <crestfallen>	hmm
Aug 13 21:36:04 <jle`>	if you want to eventually force the entire list and evaluate every item, it doesn't matter what order they are evaluated in
Aug 13 21:36:21 *	day has quit (Ping timeout: 258 seconds)
Aug 13 21:36:21 *	day__ is now known as day
Aug 13 21:36:45 <jle`>	if we are talking about the order of the items in the list...then yeah, the order i think is how it works
Aug 13 21:36:51 <jle`>	> [f] <*> [1,2] <*> [3,4] <*> [5,6]
Aug 13 21:36:54 <lambdabot>	 error:
Aug 13 21:36:54 <lambdabot>	     • Ambiguous type variable ‘b0’ arising from a use of ‘show_M922800072687...
Aug 13 21:36:54 <lambdabot>	       prevents the constraint ‘(Show b0)’ from being solved.
Aug 13 21:36:57 <jle`>	> [f] <*> [1,2] <*> [3,4] <*> [5,6] :: [Expr]
Aug 13 21:37:01 <lambdabot>	 [f 1 3 5,f 1 3 6,f 1 4 5,f 1 4 6,f 2 3 5,f 2 3 6,f 2 4 5,f 2 4 6]
Aug 13 21:37:05 <jle`>	phew
Aug 13 21:37:06 *	hackage hw-ip 2.3.4.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.4.0 (haskellworks)
Aug 13 21:38:45 <crestfallen>	ok yeah that's what I had in mind
Aug 13 21:38:46 *	fjellfras (~fjellfras@49.248.13.74) has joined
Aug 13 21:39:03 *	linarcx (~linarcx@151.241.55.125) has joined
Aug 13 21:39:47 <crestfallen>	see jle` I figured I'll never get this stuff until I really master the evaluation and appropriate notation to express it, to say a young person.
Aug 13 21:40:27 <crestfallen>	especially(?) in the case of recursive evaluation
Aug 13 21:41:07 <crestfallen>	there's also the question of how the evaluation should look with impure objects..
Aug 13 21:41:27 <jle`>	what is an 'impure object' ?
Aug 13 21:42:27 <crestfallen>	well, for example:   ...
Aug 13 21:42:57 *	nineonine (~nineonine@216-19-190-182.dyn.novuscom.net) has joined
Aug 13 21:42:59 <crestfallen>	https://paste.ee/p/mtC66
Aug 13 21:43:23 <crestfallen>	maybe what I mean is IO, return, etc.
Aug 13 21:43:32 *	nineonin_ (~nineonine@tst-vpn.calabrio.com) has joined
Aug 13 21:43:49 <jle`>	neither IO nor return nor etc. are 'impure objects' :)
Aug 13 21:44:09 <crestfallen>	etc isn't? :)
Aug 13 21:44:13 <jle`>	;)
Aug 13 21:44:27 <Lycurgus>	only foreign
Aug 13 21:44:47 <crestfallen>	but how to write it out..
Aug 13 21:45:10 <crestfallen>	for example the above more recent paste
Aug 13 21:45:25 <crestfallen>	how to write out the evaluation steps
Aug 13 21:45:59 <crestfallen>	where they use replicate with a function which seems odd to me
Aug 13 21:46:00 <jle`>	for which one?
Aug 13 21:46:11 <crestfallen>	getChars'
Aug 13 21:46:48 <crestfallen>	lines 11,12
Aug 13 21:47:05 <jle`>	just follow normal rules
Aug 13 21:47:13 <jle`>	are you familiar with 'evaluation by substitution' ?
Aug 13 21:47:25 <crestfallen>	yeah
Aug 13 21:47:26 <jle`>	basically: every time you see something like 'f x', replace it with the definition of f
Aug 13 21:47:27 *	nineonine has quit (Ping timeout: 258 seconds)
Aug 13 21:47:44 *	keepLearning512 (~keepLearn@106.51.235.188) has joined
Aug 13 21:47:47 <jle`>	do you see how this applies to getChars ?
Aug 13 21:47:51 <jle`>	(the first one)
Aug 13 21:48:12 <jle`>	try evaluating 'getChars 2' by hand
Aug 13 21:49:20 *	cur8or (~cur8or@2c0f:fbe1::140f:956c:a830:4a04) has joined
Aug 13 21:50:06 *	Sgeo has quit (Read error: Connection reset by peer)
Aug 13 21:50:34 *	Sgeo (~Sgeo@ool-18b98455.dyn.optonline.net) has joined
Aug 13 21:50:37 <crestfallen>	getChars 2 = pure (:) <*> getChar <*> getChars (2-1)
Aug 13 21:51:18 <crestfallen>	H:  <*> getChar <*> getChars (1)
Aug 13 21:51:30 *	UpstreamSalmon has quit (Quit: Connection closed for inactivity)
Aug 13 21:51:43 *	merijn has quit (Ping timeout: 245 seconds)
Aug 13 21:52:11 <crestfallen>	 or is it       H:[]  <*> getChar <*> getChars (1)
Aug 13 21:52:55 <jle`>	`pure (:) <*> getChar <*> getChars 1`
Aug 13 21:53:02 <jle`>	and from there you can expand getChars 1 again
Aug 13 21:53:30 <crestfallen>	so there's no [] of course
Aug 13 21:53:40 <jle`>	not that i see yet
Aug 13 21:54:04 <jle`>	nothing we have yet seen introduces a []
Aug 13 21:54:07 <crestfallen>	but do you not do:     H:i   ->   Hi
Aug 13 21:54:20 <jle`>	are you talking about 'pure' here?
Aug 13 21:54:36 *	ironhaven has quit (Ping timeout: 272 seconds)
Aug 13 21:54:39 <jle`>	pure here is :: a -> IO a, it is a completely different function than pure for lists
Aug 13 21:54:53 *	danvet (~Daniel@2a02:168:569e:0:3106:d637:d723:e855) has joined
Aug 13 21:56:09 <crestfallen>	oh so pure (:) is Cons for IO but doesn't actually denote Cons operator?
Aug 13 21:56:22 <Axman6>	:t (:)
Aug 13 21:56:24 <lambdabot>	a -> [a] -> [a]
Aug 13 21:56:28 <Cale>	pure (:) :: IO (a -> [a] -> [a])
Aug 13 21:56:29 <Axman6>	:t pure (:)
Aug 13 21:56:31 <lambdabot>	Applicative f => f (a -> [a] -> [a])
Aug 13 21:56:42 <jle`>	crestfallen: it (:) denotes the cons operator, but the 'f' here is IO, not []
Aug 13 21:56:50 <Axman6>	a.k.a IO (a -> ([a] -> [a]))
Aug 13 21:57:09 <jle`>	note the type of pure, a -> f a
Aug 13 21:57:15 <Cale>	So then pure (:) <*> getChar :: IO ([a] -> [a])
Aug 13 21:57:16 <jle`>	a and f are allowed to vary independently
Aug 13 21:57:32 <Cale>	er
Aug 13 21:57:33 *	aarvar has quit (Ping timeout: 245 seconds)
Aug 13 21:57:37 *	cur8or has quit (Quit: My MacBook has gone to sleep. ZZZzzz…)
Aug 13 21:57:39 <Cale>	So then pure (:) <*> getChar :: IO ([Char] -> [Char]) -- rather
Aug 13 21:58:06 <Cale>	(a gets specialised to Char, because getChar can only get us a Char to supply as the first argument to (:))
Aug 13 21:59:01 <crestfallen>	ok so in terms of writing out by hand, the (:) can be used in the way of convention
Aug 13 21:59:21 <crestfallen>	just don't add list brackets
Aug 13 21:59:41 <crestfallen>	correct?
Aug 13 21:59:46 <Axman6>	I don't understand that sentence at all
Aug 13 22:00:02 <jle`>	(:) is a function, like negate or abs or not, etc.
Aug 13 22:00:10 <jle`>	it's just like 'negate' doesn't add list brackets to anything
Aug 13 22:00:30 <crestfallen>	convention meaning to convey the consing
Aug 13 22:00:48 <Axman6>	There's nothing special about (:), other than it is also a constructor, like Just. both of these are just functions
Aug 13 22:00:52 <jle`>	well, it's not a convention
Aug 13 22:00:57 <jle`>	that's what the function is
Aug 13 22:01:07 <jle`>	just like 'negate' being a negation function isn't a "convention"
Aug 13 22:01:13 <jle`>	that's...what it actually is, in the standard libraries
Aug 13 22:01:13 <crestfallen>	but you do this ie
Aug 13 22:01:15 <jle`>	> negate 3
Aug 13 22:01:18 <lambdabot>	 -3
Aug 13 22:01:30 <crestfallen>	> 1:2:[]
Aug 13 22:01:32 <lambdabot>	 [1,2]
Aug 13 22:01:36 <crestfallen>	to convey what the result is
Aug 13 22:01:45 <Axman6>	> let cons x xs = (:) x xs in cons 3 []
Aug 13 22:01:48 <lambdabot>	 [3]
Aug 13 22:01:56 <jle`>	crestfallen: you might be mixing up the function and the result of the function
Aug 13 22:02:00 *	Amras0000 has quit (Read error: Connection reset by peer)
Aug 13 22:02:01 <jle`>	'negate 3' returns -3
Aug 13 22:02:04 <jle`>	it doesn't mean that negate is -3
Aug 13 22:02:24 <jle`>	negate is a function that takes a number and returns its negation
Aug 13 22:02:35 <Axman6>	crestfallen: are you ok with the fact that the syntax [1,2,3] is syntax sugar for 1:2:3:[]?
Aug 13 22:02:37 <jle`>	but it would be incorrect to say that 'negate' == -3
Aug 13 22:02:44 <crestfallen>	yeah Axman6 
Aug 13 22:02:52 <jle`>	(:) is a function that takes an item, and a list, and returns a new list
Aug 13 22:03:01 <MarcelineVQ>	"how do I denote the reduction of using pure on (:) for IO, if it was a list I could just write [ ]"
Aug 13 22:03:36 *	cur8or (~cur8or@2c0f:fbe1::140f:956c:a830:4a04) has joined
Aug 13 22:04:06 *	Stanley00 has quit (Ping timeout: 272 seconds)
Aug 13 22:04:10 <crestfallen>	right but the return is printed, so I'm talking about in lieu of having the output in brackets, how would you write it out?
Aug 13 22:04:35 *	jusss (~user@unaffiliated/jusss) has joined
Aug 13 22:04:42 *	travis_ has quit (Ping timeout: 258 seconds)
Aug 13 22:05:21 <crestfallen>	printed to the screen, so I'm just looking for a notational convention, if I make any sense
Aug 13 22:06:40 *	fosterite has quit (Ping timeout: 264 seconds)
Aug 13 22:07:10 <jle`>	ah
Aug 13 22:07:24 <jle`>	IO is an 'abstract' data type, so i would just reduce `pure (:)` to `pure (:)` for IO
Aug 13 22:07:34 <jle`>	just like how i'd reduce `Just (:)` to `Just (:)`, for Maybe
Aug 13 22:07:38 *	dmitri has quit (Quit: This computer has gone to sleep)
Aug 13 22:07:44 *	Stanley00 (~Stanley00@unaffiliated/stanley00) has joined
Aug 13 22:07:48 *	ht_ has quit (Remote host closed the connection)
Aug 13 22:07:50 <jle`>	some people also like to reduce it to 'return' instead of 'pure', just for consistency
Aug 13 22:07:53 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 22:08:56 <jle`>	in the end when you fully redice getChars 2 in this way, you get:
Aug 13 22:09:21 <jle`>	pure (:) <*> getChar <*> (pure (:) <*> getChar <*> (pure (:) <*> getChar <*> pure []))
Aug 13 22:09:53 <jle`>	so how to examine this requires understanding how <*> works for IO
Aug 13 22:10:13 <crestfallen>	working..
Aug 13 22:10:14 <jle`>	IO is a normal data type, just like any other one
Aug 13 22:10:31 *	gienah has quit (Ping timeout: 246 seconds)
Aug 13 22:10:32 <jle`>	(<*>) for IO is pure, just as pure as it is for lists
Aug 13 22:10:48 <jle`>	so like how for lists, to understand <*>, we understand how lists define <*>.  here, for IO, to understand <*>, we understand how IO defines <*>
Aug 13 22:11:31 <jle`>	so how `iof <*> iox` works is that it takes two IO actions iof and iox, and returns a new IO action whose effects are the effects of iof, followed by the effects of iox
Aug 13 22:11:46 <jle`>	and, the important thing, 'pure x' has no IO effects
Aug 13 22:11:52 *	Frobozz has quit (Read error: Connection reset by peer)
Aug 13 22:12:32 <jle`>	oh, and that <*> is associative with respect to effects combination
Aug 13 22:12:52 <jle`>	the effects of (ioa *> iob) *> ioc are the same as the effects of ioa *> (iob *> ioc)
Aug 13 22:13:07 <jle`>	but i guess that's something you could deduce from what i said before -- it's just sequencing one after the other
Aug 13 22:13:23 <jle`>	so when you look at `pure (:) <*> getChar <*> (pure (:) <*> getChar <*> (pure (:) <*> getChar <*> pure []))`, you can see a bunch of chained <*>'s
Aug 13 22:13:32 <jle`>	and each one "combines" the effects on both sides
Aug 13 22:13:55 <jle`>	remembering that pure (:), pure [], has no effects...what can you say about the 'effects' of that final giant result?
Aug 13 22:14:14 <jle`>	if you look at all the non-pure values being <*>'d, you see there are only three: getChar, getChar, and getChar
Aug 13 22:14:31 <jle`>	so 'getChars 3' resuls in an IO action that does getChar three times
Aug 13 22:14:40 *	gienah_ has quit (Ping timeout: 258 seconds)
Aug 13 22:15:09 <crestfallen>	but <*> with pure will make each one pure as the result 
Aug 13 22:15:43 <jle`>	remember, <*> combines effects one-after-the-other
Aug 13 22:15:55 <jle`>	so `pure f <*> iox` will have the effects of pure f, then the effects of iox
Aug 13 22:16:04 <jle`>	but since pure f has no effects, then pure f <*> iox just has the effects of iox
Aug 13 22:17:23 <crestfallen>	oh man
Aug 13 22:17:35 *	hackage hw-ip 2.3.4.1 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.4.1 (haskellworks)
Aug 13 22:17:58 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 22:18:14 *	boxscape (5387ec90@gateway/web/cgi-irc/kiwiirc.com/ip.83.135.236.144) has joined
Aug 13 22:19:31 <jle`>	so this is 'kind of like' reading 0 + x + (0 + x + (0 + x + 0)) and seeing that it is just 3*x
Aug 13 22:19:57 <jle`>	or 1 * x * (1 * x * (1 * x * 1)) and seeing that it is just x^3
Aug 13 22:20:39 *	kuttifunk has quit (Remote host closed the connection)
Aug 13 22:22:05 *	nullnullnull (~no@bzq-79-179-76-17.red.bezeqint.net) has joined
Aug 13 22:22:30 <crestfallen>	jle`, so an IO return has been manipulated mathematically so to speak, so that haskell sees it as "pure", being expressed mathematically in a way that is appealing to haskell?
Aug 13 22:22:30 *	marmalodak has quit (Read error: Connection reset by peer)
Aug 13 22:22:59 <dmwit>	blech
Aug 13 22:23:08 <dmwit>	Don't anthropomorphize languages, they hate that.
Aug 13 22:23:16 *	marmalodak (~marmaloda@c-73-231-4-220.hsd1.ca.comcast.net) has joined
Aug 13 22:23:25 <Axman6>	Ruby doesn't
Aug 13 22:24:22 <crestfallen>	sorry I can't follow. if pure f <*> iox just has the effects of iox, it still has effects after it is combined, right?
Aug 13 22:24:46 <jle`>	crestfallen: remember <*> is a function
Aug 13 22:24:52 <jle`>	it takes two IO actions and returns a new IO action
Aug 13 22:25:04 <nullnullnull>	args <- getArgs      how can I get the second arg only?
Aug 13 22:25:06 <jle`>	so if i do `let ioy = pure f <*> iox`
Aug 13 22:25:15 <jle`>	nullnullnull: you can pattern match on 'args', it's just a normal list :)
Aug 13 22:25:19 <jle`>	or use any other sort of list function
Aug 13 22:25:26 *	saulzar_ (~oliver@121.99.221.201) has joined
Aug 13 22:25:26 <nullnullnull>	hmm
Aug 13 22:25:35 <nullnullnull>	cant use something like arg[2]?
Aug 13 22:25:39 *	xorander2 (~xorander@50.216.161.66.ded-dsl.fuse.net) has joined
Aug 13 22:25:49 <jle`>	crestfallen: then in that case, ioy is a new IO action. and its effects are exactly the same as the effects of iox
Aug 13 22:26:07 <jle`>	nullnullnull: you can do arg !! 1, for the second item, but remember !! is partial
Aug 13 22:26:16 *	gienah has quit (Ping timeout: 272 seconds)
Aug 13 22:26:35 <nullnullnull>	it can work for 3 items at least? to do the !! 
Aug 13 22:26:41 *	gienah (~mwright@106-69-103-113.dyn.iinet.net.au) has joined
Aug 13 22:26:44 *	gienah has quit (Changing host)
Aug 13 22:26:44 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 22:26:44 <Axman6>	nullnullnull: case args of (_:_:x:_) -> <do something with x)
Aug 13 22:26:47 <nullnullnull>	3 args
Aug 13 22:27:03 <nullnullnull>	ah then I need to save them into variables right?
Aug 13 22:27:26 *	slomo (~slomo@unaffiliated/slomo) has joined
Aug 13 22:27:32 <jle`>	it depends on what you want to do with them :)
Aug 13 22:27:35 *	xorander has quit (Ping timeout: 244 seconds)
Aug 13 22:27:39 <crestfallen>	I'm reading back, I missed plenty (5 kind people helping) but what does this mean? "  <*> is associative with respect to effects combination "
Aug 13 22:28:00 <jle`>	crestfallen: i mentioned it earlier, (ioa *> iob) *> ioc has the same effects as ioa *> (iob *> ioc)
Aug 13 22:28:01 <nullnullnull>	I wanted to do some math stuff for each arg passed
Aug 13 22:28:05 <nullnullnull>	like a + b + c
Aug 13 22:28:17 <jle`>	yeah, it can be convenient to bind them to a name
Aug 13 22:28:41 *	kuttifunk (~Thunderbi@ppp-188-174-13-155.dynamic.mnet-online.de) has joined
Aug 13 22:29:05 <dmwit>	nullnullnull: After your snippet, `args` is just a plain old list of strings. You can do whatever complicated computation on them you want, with the full power of Haskell's list-processing functions at your fingertips.
Aug 13 22:29:20 <jle`>	crestfallen: more specifically, if i set test1 = (ioa *> iob) *> ioc, and test2 = ioa *> (iob *> iob), then test1 and test2 are both io actions that have the same effects
Aug 13 22:29:41 <MarcelineVQ>	but jle`, what is an effect :D
Aug 13 22:29:57 <jle`>	the reason why i mention that is to say that we can ignore the parenthesization when reasoning about effects in the expression we were looking at
Aug 13 22:29:57 <MarcelineVQ>	and is it different than a value
Aug 13 22:30:09 <sm[m]>	a:b::c:_ <- getArgs, if you don’t want to handle anything but three arts
Aug 13 22:30:13 <sm[m]>	args
Aug 13 22:32:28 <nullnullnull>	thanks guys :) 
Aug 13 22:32:40 *	libertyprime has quit (Read error: Connection reset by peer)
Aug 13 22:32:55 *	Saulzar has quit (Ping timeout: 246 seconds)
Aug 13 22:33:44 *	dale has quit (Quit: My computer has gone to sleep)
Aug 13 22:34:30 <crestfallen>	" each one "combines" the effects on both sides"
Aug 13 22:36:28 *	agander (agander@gateway/vpn/protonvpn/agander) has joined
Aug 13 22:37:13 <crestfallen>	so does it essentially mean that that context that contains an IO effect is pure, after pure and <*> are applied. to use the word, the functions return the character/characters in a "container"
Aug 13 22:38:08 *	libertyprime (~libertypr@101.98.42.91) has joined
Aug 13 22:38:26 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 22:39:02 *	phreedom_ has quit (Remote host closed the connection)
Aug 13 22:39:03 *	jammm (~jam@i220-108-248-249.s42.a013.ap.plala.or.jp) has joined
Aug 13 22:39:04 *	jammm has quit (Changing host)
Aug 13 22:39:04 *	jammm (~jam@unaffiliated/jamm) has joined
Aug 13 22:39:15 *	gienah has quit (Ping timeout: 248 seconds)
Aug 13 22:40:34 *	xelxebar_ has quit (Remote host closed the connection)
Aug 13 22:40:52 *	fosterite (~fosterite@2601:445:447f:dd14:441a:5e8a:d6c2:4223) has joined
Aug 13 22:41:17 <crestfallen>	the functor container makes the output viable in some way for the way haskell is designed. jle`  ?
Aug 13 22:41:26 *	xelxebar (~xelxebar@gateway/tor-sasl/xelxebar) has joined
Aug 13 22:43:02 *	xelxebar has quit (Excess Flood)
Aug 13 22:43:04 *	Guest4074 (~Aftermath@94.1.24.194) has joined
Aug 13 22:43:08 <nullnullnull>	another small question:
Aug 13 22:43:15 *	jedws (~jedws@101.180.86.173) has joined
Aug 13 22:43:16 *	xelxebar (~xelxebar@gateway/tor-sasl/xelxebar) has joined
Aug 13 22:43:23 <nullnullnull>	how can I make my args global? (I have some threads and main)
Aug 13 22:43:41 *	phreedom (~quassel@gateway/tor-sasl/phreedom) has joined
Aug 13 22:43:42 <nullnullnull>	(h:p:t:_) <- getArgs
Aug 13 22:43:51 *	Foritus has quit (Read error: Connection reset by peer)
Aug 13 22:43:55 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 22:45:09 *	fosterite has quit (Ping timeout: 250 seconds)
Aug 13 22:46:10 *	X_Aftermath has quit (Ping timeout: 276 seconds)
Aug 13 22:46:10 *	alicemaz has quit (Read error: Connection reset by peer)
Aug 13 22:46:51 *	Foritus (~buggery@cpc91334-watf11-2-0-cust153.15-2.cable.virginm.net) has joined
Aug 13 22:47:05 <cocreature>	nullnullnull: don’t make them global, just pass them around (or if that gets too annoying consider something like ReaderT that takes care of passing it around behind the scenes)
Aug 13 22:47:07 *	gienah_ has quit (Ping timeout: 245 seconds)
Aug 13 22:47:52 *	alicemaz (~alice@ennoia.rheo.space) has joined
Aug 13 22:48:03 <Axman6>	those threads will be forked fro main anyway, so you just need to pass them to the threads when you fork them
Aug 13 22:48:05 <nullnullnull>	but the thread starts before main
Aug 13 22:48:06 *	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined
Aug 13 22:48:18 <Axman6>	no?
Aug 13 22:48:47 *	murgaan has quit (Ping timeout: 245 seconds)
Aug 13 22:48:59 *	pfurla has quit (Quit: gone to sleep. ZZZzzz…)
Aug 13 22:48:59 <Axman6>	main is the first thing that starts, by definition
Aug 13 22:49:26 <dminuoso>	crestfallen: What if I told you that Applicative didn't have ⌜<*>⌝, but some method ⌜><⌝ instead, with the following type signature ⌜(><) :: Applicative f=> f a -> f b -> f (a, b)⌝
Aug 13 22:49:46 *	dmitri (~dima14@ppp-124-122-27-35.revip2.asianet.co.th) has joined
Aug 13 22:49:47 <nullnullnull>	T=do       threadDelay 2000000; exitImmediately(ExitFailure 1);       main=do   etc
Aug 13 22:49:48 <dminuoso>	crestfallen: And equivalently, instead of ⌜pure⌝ you had ⌜unit :: Applicative f => f ()⌝
Aug 13 22:50:21 <crestfallen>	MarcelineVQ   " but j..le`, what is an effect :D     and is it different than a value "
Aug 13 22:50:26 <crestfallen>	good question ^
Aug 13 22:50:28 <nullnullnull>	ah u mean I need to call that thread from main
Aug 13 22:50:28 <dminuoso>	crestfallen: I think in a lot of way, Applicative is confusing because there's that notion of function application to it - but in reality the function application is not the point.
Aug 13 22:50:51 <nullnullnull>	to send args to thread
Aug 13 22:51:01 <dminuoso>	crestfallen: The point is that (><) that somehow merges together two effects and their results.
Aug 13 22:51:28 <Axman6>	nullnullnull: t doesn't do anything (alsi it can't be called T, that's not a valid variable name)
Aug 13 22:52:02 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 22:52:03 <nullnullnull>	ok mate, so I need to pass arg to the thread right? :)
Aug 13 22:52:14 <crestfallen>	dminuoso, but do the effects go away? I mean, what are effects?
Aug 13 22:52:19 <Axman6>	yes
Aug 13 22:52:38 <cocreature>	t args = …; main = do args <- getArgs; forkIO (t args); …
Aug 13 22:52:42 <dminuoso>	crestfallen: "effect" is a lose term that somehow describes that sort of "context" that separates "T A" from juts "A"
Aug 13 22:53:03 <dminuoso>	crestfallen: For each choice of T, you would think of T as having some effect in a lose notion.
Aug 13 22:53:15 *	cur8or has quit (Quit: My MacBook has gone to sleep. ZZZzzz…)
Aug 13 22:53:38 *	v01d4lph4 (~v01d4lph4@125.16.234.60) has joined
Aug 13 22:53:39 <Cale>	crestfallen: It might be clearer to start with Monad, because it's not necessary to think of these things which are producing functions as their results.
Aug 13 22:53:59 <nullnullnull>	thanks guys again :)
Aug 13 22:54:13 <crestfallen>	Cale I think j.l.e' suggested that as well, or was it you?
Aug 13 22:54:29 <Cale>	Could have been me even :D
Aug 13 22:54:38 <crestfallen>	!!
Aug 13 22:54:40 <dminuoso>	Cale: The strangest thing is, this superclass relationship is fairly misleading - I feel that Applicative is so much more orthogonal to Monad.
Aug 13 22:54:52 *	gienah has quit (Ping timeout: 268 seconds)
Aug 13 22:54:56 *	boxscape has quit (Remote host closed the connection)
Aug 13 22:55:14 <Cale>	I mean, Applicative is something you can get for free if you have Monad, so I don't find it very orthogonal
Aug 13 22:55:38 <dminuoso>	That is, Semigroup and Monoid are related differently than Applicative and Monad.
Aug 13 22:55:54 <dminuoso>	Cale: Sure, but that's just because Monad give rise to a canonical Applicative instance via Yoneda.
Aug 13 22:56:18 <dminuoso>	If you compare say Ord with Eq, where Ord is pretty much Eq plus some stuff, or Monoid which is Semigroup plus some stuff.
Aug 13 22:56:20 <MarcelineVQ>	dminuoso: my man you didn't example any effects :O
Aug 13 22:56:25 <Cale>	I don't know why it's Yoneda, but okay :)
Aug 13 22:56:42 <crestfallen>	but wait what are we trying to do with taking effects and transforming them? ultimately, it makes them mathematically in step with the rest of haskell, right?
Aug 13 22:56:59 <Cale>	crestfallen: Well, that's part of it, yeah
Aug 13 22:57:24 <Cale>	Specifically, it's necessary to have *some* type for describing IO effects
Aug 13 22:58:16 <Cale>	and then it so happens that the operations we want for those types that describe "computations having results", like IO actions, end up being patterns that happen over and over again
Aug 13 22:58:47 <Cale>	So we end up defining these type classes like Applicative and Monad to capture the pattern which is common across many libraries (IO being just one of them)
Aug 13 22:59:17 *	petersen (~petersen@redhat/juhp) has joined
Aug 13 22:59:18 <Cale>	Like any abstraction, it'll make a whole lot more sense as you pick up more and more examples
Aug 13 22:59:38 <phadej>	I think dminuoso tries  to say that Applicative and Monad superclass relationship is more of accidental
Aug 13 22:59:46 <Cale>	There are not many relevant examples of instances of Applicative which are not also instances of Monad though
Aug 13 22:59:50 <phadej>	e.g. Arrow and Monad aren't related
Aug 13 23:00:01 *	milky1 has quit ()
Aug 13 23:00:01 <phadej>	but both can be used to describe effects
Aug 13 23:00:21 <dminuoso>	phadej: Right. Unlike a Monoid where you would think of it as an upgraded Semigroup.
Aug 13 23:00:27 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 23:00:52 *	gienah_ has quit (Ping timeout: 245 seconds)
Aug 13 23:01:02 <dminuoso>	phadej: Unless of course there was some sort of free monad with a forgetful adjoint that somehow downgraded Monad to Applicative. Is that even a thing?
Aug 13 23:01:28 <crestfallen>	A functor is a context that stores data in a distinct form. so we need to be able to handle them like they were more standard values, so they are a particular kind of ADT essentially
Aug 13 23:02:03 <Cale>	crestfallen: That first sentence is a bit word-saladish to me... I don't know what the word "context" means there
Aug 13 23:02:07 <phadej>	no, in general (CT), the requirements [to applicative like thing and monad to be related] on a category are quite strong
Aug 13 23:02:11 <Axman6>	:t guard
Aug 13 23:02:13 <lambdabot>	Alternative f => Bool -> f ()
Aug 13 23:02:50 <Cale>	crestfallen: At least for the case of Haskell, a functor is a parametric data type F for which we can define a function  fmap :: (a -> b) -> F a -> F b
Aug 13 23:03:09 <Axman6>	> guard True (Just 1)
Aug 13 23:03:13 <lambdabot>	 error:
Aug 13 23:03:13 <lambdabot>	     • No instance for (Alternative ((->) (Maybe Integer)))
Aug 13 23:03:13 <lambdabot>	         arising from a use of ‘guard’
Aug 13 23:03:14 <Cale>	crestfallen: Lists are a good first example of that, since everyone comes across map early on
Aug 13 23:03:33 <Axman6>	> guard True *> Just 1
Aug 13 23:03:35 <lambdabot>	 Just 1
Aug 13 23:03:42 <crestfallen>	I was watching bartosz milewski who was talking about their (functors) efficiency in memory
Aug 13 23:03:54 <Cale>	crestfallen: But also, we can have more interesting things. Let's define our own type for representing IO actions
Aug 13 23:04:01 <dminuoso>	Lists are also an interesting concept because the "effect" they model is the one of non-determinism. By that I mean that [1,2,3] doesn't mean a sequence of three numbers. It rather means "It's some number (out of three), but we dont know which one exactly"
Aug 13 23:04:31 <Cale>	data TermIO a = Done a | PutStr String (TermIO a) | GetLine (String -> TermIO a)
Aug 13 23:04:36 <Cale>	Let's just start with this one :)
Aug 13 23:04:37 <dminuoso>	So the difference between 2 and [1,2,3] is that the list adds some sort of "fuzziness", and that's the effect the Applicative and Monad instances talk about.
Aug 13 23:04:45 <Cale>	Are you familiar with this syntax?
Aug 13 23:05:05 <Cale>	We're defining a data type with three constructors, Done, PutStr, and GetLine
Aug 13 23:05:18 <dminuoso>	phadej: Interesting, what kind of constraints are those?
Aug 13 23:05:38 <crestfallen>	dminuoso, sorry if that is for my benefit I don't follow . very sorry
Aug 13 23:05:54 <crestfallen>	Cale one sec
Aug 13 23:06:23 *	murgaan (~murgaan@static-47-190-6-53.dlls.tx.frontiernet.net) has joined
Aug 13 23:06:31 <Cale>	The idea is, that any action (whose result has type a) is either going to be Done, along with a value of type a that it finishes with, or it will start off by printing a string to the terminal (followed by some other action whose result will have type a)
Aug 13 23:07:02 <Cale>	... or it will start by getting a line of text from the user, and then based on the String result of that, decide which action to perform next
Aug 13 23:07:10 <MarcelineVQ>	The terminology overload is getting steamy in here.
Aug 13 23:07:14 <Cale>	(and that action will have a result of type a)
Aug 13 23:08:03 *	xelxebar_ (~xelxebar@gateway/tor-sasl/xelxebar) has joined
Aug 13 23:08:40 *	xelxebar has quit (Ping timeout: 260 seconds)
Aug 13 23:10:10 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 23:11:07 <crestfallen>	ok thanks Cale I follow that pretty well
Aug 13 23:11:17 *	gienah has quit (Ping timeout: 245 seconds)
Aug 13 23:11:45 <Cale>	crestfallen: Okay, so we could write a Functor instance for this too
Aug 13 23:11:56 <Cale>	instance Functor TermIO where
Aug 13 23:12:10 <Cale>	  fmap f (Done a) = Done (f a)
Aug 13 23:12:38 <Cale>	  fmap f (PutStr str x) = PutStr str (fmap f x)
Aug 13 23:13:12 <Cale>	  fmap f (GetLine k) = GetLine (\str -> fmap f (k str))
Aug 13 23:13:15 <jle`>	crestfallen: IO is not a container
Aug 13 23:13:33 <jle`>	oh, i should have read scrollback
Aug 13 23:13:36 <Cale>	Well, I'm kind of in the middle of showing the sense in which IO is kind of container-ish
Aug 13 23:13:43 <jle`>	yes, please igore me :)
Aug 13 23:14:01 <crestfallen>	thanks so much jle` for everything!
Aug 13 23:14:29 *	sdx23 has quit (Remote host closed the connection)
Aug 13 23:14:31 <Cale>	crestfallen: Does that implementation of fmap make sense? The end result is that we're applying f to the results of our TermIO action
Aug 13 23:15:19 <Cale>	The first line there says that if our action is simply the trivial one which produces a result, then fmap f will transform it into a similar one, but with f applied to the result
Aug 13 23:16:05 <Cale>	The second line says that if our action starts off by printing a string, then it still will start off that way, but we'll fmap f over the action which follows that
Aug 13 23:16:49 <crestfallen>	the action?
Aug 13 23:17:03 <crestfallen>	fmap f x    ?
Aug 13 23:17:04 <Cale>	Well, I'm going to refer to values of type TermIO a as "actions"
Aug 13 23:17:26 <Cale>	and in particular, the action I was referring to was the x in fmap f x, yeah
Aug 13 23:17:57 *	sdx23 (~sdx23@unaffiliated/sdx23) has joined
Aug 13 23:18:26 <Cale>	Values of type TermIO a are simply describing things to be done -- if we want to actually print strings on the terminal, or get text from a user, we'll need to implement a way of executing them
Aug 13 23:18:26 <crestfallen>	ok
Aug 13 23:18:47 *	drewbarbs has quit (Ping timeout: 245 seconds)
Aug 13 23:18:52 *	fosterite (~fosterite@2601:445:447f:dd14:441a:5e8a:d6c2:4223) has joined
Aug 13 23:19:04 *	heatsink has quit (Remote host closed the connection)
Aug 13 23:19:16 *	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has joined
Aug 13 23:19:29 *	wjp1 (~wjp@139.28.218.198) has joined
Aug 13 23:19:37 *	travis_ (~travis@cpe-108-185-149-115.socal.res.rr.com) has joined
Aug 13 23:19:58 <Cale>	The last line there, fmap f (GetLine k) = GetLine (\str -> fmap f (k str)) says that if the given action starts off by getting a line of text from the user, and then proceeds to use k to decide what steps to take next
Aug 13 23:20:30 <Cale>	then our resulting action will get a line of text from the user, and then, given the string the user typed is str,
Aug 13 23:20:44 *	lastmanstanding has quit (Ping timeout: 272 seconds)
Aug 13 23:20:49 <Cale>	apply k to str to get an action to be performed next, but fmap f over that
Aug 13 23:21:04 <Cale>	(so as to transform the eventual result)
Aug 13 23:21:16 <Cale>	Make sense?
Aug 13 23:21:28 <crestfallen>	what is k ?
Aug 13 23:21:47 <Cale>	So, GetLine :: (String -> TermIO a) -> TermIO a
Aug 13 23:22:03 *	drewbarbs (~drewbarbs@2601:14a:700:eaa1:b4d1:3650:4556:2d71) has joined
Aug 13 23:22:05 <Cale>	Takes a function which will decide how to proceed given the user's input
Aug 13 23:22:30 <Cale>	Of course, that's just how I'm interpreting it, it's really just an arbitrary function
Aug 13 23:22:37 *	merijn has quit (Ping timeout: 268 seconds)
Aug 13 23:23:14 *	gienah_ has quit (Ping timeout: 268 seconds)
Aug 13 23:23:19 <Cale>	So that we can eventually encode actions which proceed differently based on what the user types
Aug 13 23:23:32 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 23:23:36 <Cale>	(which is something you often want programs to be able to do)
Aug 13 23:24:04 *	fosterite has quit (Ping timeout: 264 seconds)
Aug 13 23:24:18 <Cale>	We can write an interpreter which will transform our TermIO actions into plain Haskell IO actions:
Aug 13 23:24:26 <Cale>	execute :: TermIO a -> IO a
Aug 13 23:24:32 <Cale>	execute (Done v) = return v
Aug 13 23:24:53 <Cale>	execute (PutStr str x) = do putStr str; execute x
Aug 13 23:24:56 *	wroathe has quit (Ping timeout: 244 seconds)
Aug 13 23:25:10 <Cale>	execute (GetLine k) = do str <- getLine; execute (k str)
Aug 13 23:26:09 <Cale>	You can imagine that IO is similar to our TermIO type, and that inside the Haskell runtime there is a similar program which is pattern matching on the constructors of IO and carrying out the steps described.
Aug 13 23:26:35 <Cale>	(It's not actually, it's an ugly hack for performance and ease of compiler implementation, but it *could* be)
Aug 13 23:27:33 *	marek has quit (Ping timeout: 268 seconds)
Aug 13 23:27:34 <crestfallen>	shall Plan A be to start reading about Monads?
Aug 13 23:27:51 <Cale>	Well, I'm getting there :)
Aug 13 23:27:59 <Cale>	Let's start with a few *particular* monads
Aug 13 23:28:09 <Cale>	and then worry about the abstraction a bit after
Aug 13 23:28:27 <Cale>	We could look at how (>>=) is implemented for this TermIO type
Aug 13 23:28:35 *	gienah_ (~mwright@gentoo/developer/gienah) has joined
Aug 13 23:28:48 *	gienah has quit (Ping timeout: 245 seconds)
Aug 13 23:28:50 <Cale>	(>>=) :: TermIO a -> (a -> TermIO b) -> TermIO b
Aug 13 23:28:57 <Cale>	The idea with this type
Aug 13 23:28:58 *	fphilipe_ has quit (Ping timeout: 272 seconds)
Aug 13 23:29:02 *	marek (~marek@90.176.6.54) has joined
Aug 13 23:29:05 <crestfallen>	I'm not sure I'm capable at this moment tbh
Aug 13 23:29:08 <Cale>	is that we're giving an action of type TermIO a to start off with
Aug 13 23:29:28 *	satoshi (~satoshi@23.83.251.134) has joined
Aug 13 23:29:42 <Cale>	and then a function which will take the result of that first TermIO action, (which has type a), and produce an action of type TermIO b to continue with
Aug 13 23:29:55 <Cale>	and (>>=) is going to glue those together into a single action
Aug 13 23:30:27 <Cale>	crestfallen: Totally lost?
Aug 13 23:30:47 <Cale>	Maybe we could just start with other examples of monads, if you're not having an easy time with this one
Aug 13 23:30:51 *	lastmanstanding (~arjoonn@103.79.223.74) has joined
Aug 13 23:30:55 <crestfallen>	yeah sorry I'm pretty lost. I understand the cases based on the user input
Aug 13 23:31:07 <Cale>	okay
Aug 13 23:32:00 *	vlatkoB (~IRC_clien@unaffiliated/vlatkob) has joined
Aug 13 23:32:08 *	kungp has quit (Ping timeout: 272 seconds)
Aug 13 23:32:36 <Cale>	So yeah, the idea here is just that we can make data types whose values represent "computations" or "actions" to be performed. This is a common strategy across many Haskell libraries. What those computations are allowed to do varies...
Aug 13 23:33:06 <Cale>	For example, we might have a type  Parser a  for things which try to consume the start of an input string, and, if successful, produce a result of type a
Aug 13 23:33:07 *	gienah_ has quit (Ping timeout: 248 seconds)
Aug 13 23:33:20 *	kungp (~kp@185.21.216.142) has joined
Aug 13 23:33:39 *	DTZUZO has quit (Ping timeout: 248 seconds)
Aug 13 23:33:43 *	libertyprime has quit (Ping timeout: 268 seconds)
Aug 13 23:33:53 <crestfallen>	so each action needs to ultimately be pure, right?
Aug 13 23:34:16 <Cale>	Our description of what is to be done is
Aug 13 23:34:23 <Cale>	Actually carrying out the steps might not be
Aug 13 23:34:32 *	MarcelineVQ has quit (Read error: Connection reset by peer)
Aug 13 23:34:38 *	gienah (~mwright@gentoo/developer/gienah) has joined
Aug 13 23:34:54 *	MVQq (~anja@xplr-104-249-247-127.xplornet.com) has joined
Aug 13 23:34:56 *	satoshi has quit ()
Aug 13 23:35:08 <Cale>	Yeah, the real thing I'm getting at with the TermIO example was to try to give some sense that IO action values are just ordinary values, even though IO is an opaque type
Aug 13 23:35:58 *	MVQq has quit (Remote host closed the connection)
Aug 13 23:36:32 <crestfallen>	opaque
Aug 13 23:36:33 *	MarcelineVQ (~anja@xplr-104-249-247-127.xplornet.com) has joined
Aug 13 23:36:44 <Cale>	as in, its implementation is hidden from us
Aug 13 23:36:52 <Cale>	We can't pattern match on its constructors
Aug 13 23:37:13 <Cale>	"abstract" would be another word for it
Aug 13 23:37:33 *	xff0x has quit (Ping timeout: 245 seconds)
Aug 13 23:37:34 <Lycurgus>	and definitely not as a shoehorned kludge to get IO in FP
Aug 13 23:38:05 <crestfallen>	 We can't pattern match on its constructors    << sorry pretty confused
Aug 13 23:38:35 <Cale>	Like, normally, if we define some data type like:
Aug 13 23:38:47 <Cale>	data List a = Empty | Cons a (List a)
Aug 13 23:39:08 <Cale>	We can see the constructors Empty and Cons, and use them to take apart values of type List a
Aug 13 23:39:19 <crestfallen>	right
Aug 13 23:39:22 <dminuoso>	Cale: You can only pattern match on a constructor if the implementor gives it to you. Hiding the data constructor is a mechanism of hiding implementation (such that you cant just arbitrarily break it apart and look inside)
Aug 13 23:39:22 <Cale>	But imagine they're not exported from the module in which they're defined
Aug 13 23:39:37 <dminuoso>	So it's encapsulation. :)
Aug 13 23:39:44 *	travis_ has quit (Ping timeout: 272 seconds)
Aug 13 23:40:04 <Cale>	We could export just some basic lists and ways of working with them, without exposing our specific implementation of lists
Aug 13 23:40:30 <Cale>	If you look at Data.Sequence, it's very much like that, actually
Aug 13 23:40:42 *	rainmanjam (~rainmanja@71-36-127-83.ptld.qwest.net) has joined
Aug 13 23:40:52 *	fphilipe_ (~phil@46-127-142-222.dynamic.hispeed.ch) has joined
Aug 13 23:40:53 <Cale>	From outside, it's something which looks like a list, internally, it's a weird tree thingy
Aug 13 23:41:11 <Cale>	(with some really nice asymptotics for concatenating and splitting)
Aug 13 23:42:05 <nullnullnull>	I sent variable to thread:   thread t;       how can I receive it from the thread? is it like this:  thread:: t -> Int()
Aug 13 23:42:23 <Cale>	IO is also like that, we can't tell from what the IO library gives us how the data type is implemented -- we're just given a bunch of basic IO actions and ways of combining them together.
