<crestfallen>	> (<$>) (foldr (+) 0) [(Just 4.5), (Just 2), (Just 3.3)]
<lambdabot>	 [4.5,2.0,3.3]
<crestfallen>	weird that's not what I expected
<dmwit>	> map sum [Just 4.5, Just 2, Just 3.3]
<lambdabot>	 [4.5,2.0,3.3]
<EvanR>	> sum (Just 4.5)
<lambdabot>	 4.5
<dmwit>	> map (foldr f z) [Nothing, Just x]
<lambdabot>	 error:
<lambdabot>	     Ambiguous occurrence ‘x’
<lambdabot>	     It could refer to either ‘Debug.SimpleReflect.x’,
<dmwit>	?undefine
<lambdabot>	Undefined.
<dmwit>	> map (foldr f z) [Nothing, Just x]
<lambdabot>	 [z,f x z]
*	toppler (~user@mtop.default.momentoftop.uk0.bigv.io) has joined
<crestfallen>	sorry wait not following
*	DANtheBEASTman (~dysfigure@li1148-161.members.linode.com) has joined
*	slomo has quit (Ping timeout: 268 seconds)
*	rosterok (uid236576@gateway/web/irccloud.com/x-ssjcxdkqijapeeyo) has joined
*	zwarag has quit (Ping timeout: 250 seconds)
<EvanR>	> foldr (liftA2 (+)) (Just 0) [Just 4.5, Just 2, Just 3.3]
<lambdabot>	 Just 9.8
<MarcelineVQ>	Before the flood shall we ask what was expected?
<higherorder>	dmwit: thanks for chiming in :) Would it still be "idiomatic" to use Either in cases where the two sides are of "equal meaning"? Or would a Haskell dev reading the code frown ?
*	penthium2 has quit ()
*	DANtheBEASTman has quit (Client Quit)
<dmwit>	I will not frown. Also, if I am writing the code, I will make my own type that labels the two branches more descriptively.
*	DANtheBEASTman (~dysfigure@li1148-161.members.linode.com) has joined
*	DANtheBEASTman has quit (Client Quit)
<EvanR>	you can nest Eithers to "implement" any sum type you want, but the result is like using String for all your data
*	DANtheBEASTman (~dysfigure@li1148-161.members.linode.com) has joined
*	heatsink (~heatsink@2600:1700:bef1:5e10:f1ca:43ba:7c4b:388f) has joined
<dmwit>	For example, https://github.com/dmwit/nurse-sveta/blob/master/src/Dr/Mario/Sveta.hs#L76-L79
<dmwit>	(Chosen just because the example is fresh in my mind -- just wrote it yesterday -- which should serve as a piece of evidence about how often this kind of thing comes up. ;-)
*	mdunnio (~mdunnio@208.59.170.5) has joined
*	zwarag (~zwarag@80-110-97-183.cgn.dynamic.surfer.at) has joined
<crestfallen>	well first off, why does 'map sum' work on functor elements in the list?
<dmwit>	It doesn't. It works on foldable elements in the list.
<dmwit>	:t sum
<lambdabot>	(Foldable t, Num a) => t a -> a
<dmwit>	:t map sum
<lambdabot>	(Foldable t, Num b) => [t b] -> [b]
*	jneira (4f9b01a2@gateway/web/cgi-irc/kiwiirc.com/ip.79.155.1.162) has joined
*	heatsink has quit (Ping timeout: 250 seconds)
<EvanR>	map is still specialized to list?
*	albertus1 has quit (Ping timeout: 250 seconds)
<dmwit>	Sure. We already have the perfectly good name fmap for the generalized one.
<dmwit>	(Two names for it, in fact!)
<crestfallen>	wait but there's no accum so that is still a fold?
<dmwit>	I don't understand that question. What is your definition of "fold"? What is your definition of "accum"?
<dignissimus>	I only half understand why this doesn't work, I think because I'm using haskeline, instead of being IO objects, things should be InputT IO objects? But I don't understand what should be an InputT IO object or why or how to make it one https://paste.rs/16Y.hs https://paste.rs/JgB
<dmwit>	(...and why do you believe "there's no accum"?)
<crestfallen>	what is being summed? in your first example with 'map sum'
*	DANtheBEASTman has quit (Quit: I hate quit messages.)
<EvanR>	(i guess i was surprised and relieved that it didn't say (Functor f, Foldable t, Num b) => f (t b) -> f b
<EvanR>	)
<dmwit>	In `sum (Just 4.5)`, the elements of the Maybe Double, namely, 4.5, are being summed.
*	DANtheBEASTman (~dysfigure@li1148-161.members.linode.com) has joined
<crestfallen>	ok
<dignissimus>	I know by using `a <- return newStdGen`  I can make `a` an `IO StdGen` object but that's not useful because I want to be able to use an StdGen object
<dmwit>	dignissimus: Seems like you just need to insert a `lift` or `liftIO` there, as in `generator <- liftIO newStdGen`.
<dmwit>	With such a short transformer stack, the choice between `lift` and `liftIO` is mostly aesthetic. If you plan to refactor later, `liftIO` is the more forward-compatible choice.
*	mdunnio has quit (Remote host closed the connection)
*	albertus1 (~seb@46.114.0.26) has joined
*	mdunnio (~mdunnio@208.59.170.5) has joined
*	albertus1 has quit (Max SendQ exceeded)
<dmwit>	dignissimus: ...but since you're doing IO already, can I recommend switching from `randomR` to `randomRIO`?
*	hackage cpsa 3.6.4 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.6.4 (mliskov)
<dmwit>	That will take care of keeping a reference to the seed around, so that future invocations of `aiPlayerLogic` don't keep reseeding.
*	zincy_ has quit (Read error: Connection reset by peer)
*	tom_ has quit (Remote host closed the connection)
<dmwit>	s/future/multiple/
<crestfallen>	> map (foldr f z) [Nothing, Just x]
<lambdabot>	 [z,f x z]
*	zincy_ (~tom@95.147.48.210) has joined
<crestfallen>	??
*	tom_ (~tom@95.147.48.210) has joined
<dminuoso>	dignissimus: note that in principle `a <- return newStdGen` is roughly equivalent to `let a = newStdGen` :)
<crestfallen>	what's happening there
<EvanR>	> foldr f z (Just x)
<lambdabot>	 f x z
*	janat08 has quit (Quit: Connection closed for inactivity)
<dminuoso>	dignissimus: (Im saying roughly because there are a few legitimate use cases of using the former style, when `a` is a more complicated pattern like `Just a`)
*	albertus1 (~seb@46.114.0.26) has joined
<EvanR>	crestfallen: again with the Foldable behavior of Maybe
*	albertus1 has quit (Max SendQ exceeded)
<dmwit>	crestfallen: It was just a quick way to show you the definition of foldr for Maybe.
<dmwit>	Specifically:
<dmwit>	foldr f z Nothing = z
*	albertus1 (~seb@46.114.0.26) has joined
<dmwit>	foldr f z (Just x) = f x z
*	tom_ has quit (Remote host closed the connection)
*	tom_ (~tom@213.205.241.24) has joined
*	tom_ has quit (Read error: Connection reset by peer)
<dmwit>	(I don't know if the implementation of `foldr` for `Maybe` is literally these lines of code, but they're equivalent to it anyway.)
*	zincy_ has quit (Read error: Connection reset by peer)
*	tom_ (~tom@95.147.48.210) has joined
<EvanR>	@src maybe
<lambdabot>	maybe n _ Nothing  = n
<lambdabot>	maybe _ f (Just x) = f x
*	zincy_ (~tom@95.147.48.210) has joined
<dmwit>	Of course to fully explain what happened we'd have to take a detour through some pretty hairy stuff to explain how the Expr type is implemented. But I think it's just a distraction. If you can understand the above equations you've learned everything I wanted you to learn from that lambdabot query.
*	tom_ has quit (Read error: Connection reset by peer)
*	hiroaki (~hiroaki@ip4d166aa9.dynamic.kabel-deutschland.de) has joined
*	tom_ (~tom@95.147.48.210) has joined
*	tom_ has quit (Read error: Connection reset by peer)
*	pera has quit (Ping timeout: 240 seconds)
<crestfallen>	tbh I'm confused...working on it
<EvanR>	folding over a Maybe (with foldr) seems kind of an oddball thing to do. "folding" it with maybe seems more applicable and theoretically nice
*	zincy_ has quit (Read error: Connection reset by peer)
*	paulasdf (~paulasdf@2601:1c1:c200:2d8c:3b02:890a:8d63:6fa7) has joined
*	toppler has quit (Ping timeout: 276 seconds)
<dmwit>	I think having a Foldable instance for Maybe is nice. traverse_ has been handy a few times.
<dignissimus>	Ok, I've replaced the randomR call with one to randomRIO imported and used liftIO and the programme works! Thanks all 
<EvanR>	yeah the oddball Foldable instances seem to exist so Traversable works
<dmwit>	dignissimus: Nice! ^_^
<dmwit>	traverse_ doesn't use Traversable
<dignissimus>	liftIO will be very useful to know about later on too
<EvanR>	:t traverse_
<lambdabot>	(Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
*	albertus1 has quit (Ping timeout: 265 seconds)
<EvanR>	:t for
<lambdabot>	(Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
*	replay has quit (Quit: Textual IRC Client: www.textualapp.com)
*	is_null has quit (Ping timeout: 246 seconds)
<EvanR>	k so traverse_ is like a highbrow way to do `when' heh
<crestfallen>	> foldr f z (Just x)
<lambdabot>	 f x z
<crestfallen>	so you don't call z the accumulator
<EvanR>	z is the base value or zero value
*	Lears has quit (Remote host closed the connection)
<dmwit>	I don't. But I would probably understand what you meant if you did.
<EvanR>	> foldr f z Nothing
<lambdabot>	 z
*	Lears (~leary@122-58-153-250-adsl.sparkbb.co.nz) has joined
<EvanR>	the initial value of the accum
*	xsperry (~bc8163c6@217.29.117.252) has joined
*	turab has quit (Ping timeout: 252 seconds)
*	dm9 has quit (Ping timeout: 245 seconds)
<crestfallen>	> map (foldr f z) [Nothing, Just x]
<lambdabot>	 [z,f x z]
<dmwit>	higherorder: Oh yeah, and I've written about this on SO, too! https://stackoverflow.com/a/19073039/791604
<crestfallen>	so there, z becomes the second param of f
<higherorder>	dmwit: oh great, thanks!
<EvanR>	crestfallen: so you can accurately understand all this by considering Maybe as a list with at most 1 element
<EvanR>	> foldr f z [x]
<lambdabot>	 f x z
<EvanR>	> foldr f z []
<lambdabot>	 z
*	turab (~turab@149-160-216-59.dhcp-bl.indiana.edu) has joined
<EvanR>	[x] corresponds to Just x
<crestfallen>	ok copy that but...
*	dm9 (~weechat@p5083AC11.dip0.t-ipconnect.de) has joined
*	takuan (~takuan@d54C0606B.access.telenet.be) has joined
*	albertus1 (~seb@46.114.0.26) has joined
<crestfallen>	why would you have the base value returned as the 2nd param of f as in f x z ?
<EvanR>	that's just the order foldr uses
<dmwit>	crestfallen: Okay, I accept your challenge. I decide not to use z. What do you propose that I use instead?
*	efm has quit (Ping timeout: 268 seconds)
<EvanR>	first arg is "this element" and second arg is "the running total"
*	reggie_ has quit (Remote host closed the connection)
<dmwit>	(The second argument is not a "running total". For that to be a sensible description, the second argument would have to change. It doesn't.)
<crestfallen>	its very interesting, hold on pls
<EvanR>	well, nothing ever changes :) five reasons at least
<EvanR>	> foldr f z [x,y]
<lambdabot>	 f x (f y z)
<dmwit>	(This is related to my comment earlier, "I don't [call z the accumulator].".)
<EvanR>	yeah z is not the accumulator
<crestfallen>	ok base value
<EvanR>	but the second argument is the accumulator
*	Gurkenglas (~Gurkengla@unaffiliated/gurkenglas) has joined
*	fphilipe has quit (Ping timeout: 265 seconds)
<EvanR>	in the lazy case, for foldr, this accumulator has already accumulated, but we can ignore that for now 
*	reggie_ (~reggie@c-73-35-135-140.hsd1.wa.comcast.net) has joined
*	fizbin (~fizbin@2603:3004:624:7f80:1501:23df:7e3f:a421) has joined
*	toppler (~user@mtop.default.momentoftop.uk0.bigv.io) has joined
<dmwit>	EvanR: All (recursive) calls to foldr see the same value in `z`. Compare `foldl'`, which actually see different values in this argument in the straightforward implementation.
<EvanR>	all recursive calls don't see the same value, they are not all z
<dmwit>	?src foldr
*	Rudd0^ has quit (Read error: Connection reset by peer)
<lambdabot>	foldr f z []     = z
<lambdabot>	foldr f z (x:xs) = f x (foldr f z xs)
*	Rudd0 has quit (Read error: Connection reset by peer)
<dmwit>	See? It is passed to the recursive foldr call unchanged.
<dmwit>	?src foldl'
<lambdabot>	foldl' f a []     = a
<lambdabot>	foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
<EvanR>	the second argument is not z, its foldr f z xs
*	efm (~efm@vpn.tummy.com) has joined
<dmwit>	^ Here, not
<EvanR>	to f
<EvanR>	not to foldr
<dmwit>	EvanR: All (recursive) calls to *foldr* see the same value in `z`.
<EvanR>	i think that might be the confusion
<dmwit>	Is what I said.
<crestfallen>	yikes
<dmwit>	Which is *different* to the way other recursive functions behave, and specifically different to the style of recursive function where I'm comfortable calling one argument an accumulator.
<EvanR>	i was thinking in terms of "being in the function" not foldr itself
<slack1256>	Is there an standard resource for learning about free theorems and how to derive them on haskell?
*	mike64 (a6461f1c@166.70.31.28) has joined
<crestfallen>	in this simple example, (+) is not returned along with the base value:
<crestfallen>	> foldr (+) 5 [1,2,3,4]
<lambdabot>	 15
*	fphilipe (~phil@81.6.34.65) has joined
<EvanR>	> foldr f 5 [1,2,3,4]
<lambdabot>	 error:
<lambdabot>	     • Ambiguous type variable ‘a0’ arising from a use of ‘show_M590353136163...
<lambdabot>	       prevents the constraint ‘(Show a0)’ from being solved.
<dmwit>	slack1256: Wadler's paper "Theorems for Free!" is quite approachable.
<slack1256>	Got it!
<EvanR>	f 1 (f 2 (f 3 (f 4 5)))
<EvanR>	so second arg is an accumulator
<mike64>	@djinn (((a->b)->b)->b) -> (a -> b)
<lambdabot>	f a b = a (\ c -> c b)
*	fizbin has quit (Ping timeout: 245 seconds)
*	mike64 has quit (Remote host closed the connection)
<EvanR>	(second arg to foldr def not)
<crestfallen>	def == definitely EvanR ?
<EvanR>	yes
<EvanR>	z is the base
<EvanR>	base case
*	vicfred has quit (Quit: Leaving)
*	DTZUZO (~DTZUZO@S0106bcd165662a4d.vs.shawcable.net) has joined
*	ariakenom has quit (Quit: WeeChat 2.6)
*	seedvray has quit (Ping timeout: 265 seconds)
*	efm has quit (Read error: Connection reset by peer)
*	albertus1 has quit (Ping timeout: 268 seconds)
*	efm (~efm@vpn.tummy.com) has joined
*	conal has quit (Quit: Computer has gone to sleep.)
*	shaunm1 (~shaunm@185.103.96.143) has joined
*	mike8 (a6461f1c@166.70.31.28) has joined
*	cosimone has quit (Quit: Terminated!)
<mike8>	@djinn (((a->b)->b)->b) -> (a->b)
<lambdabot>	f a b = a (\ c -> c b)
*	mike8 has quit (Remote host closed the connection)
*	conal (~conal@209.209.238.179) has joined
<literallyCrevice>	I'm looking for a custom prelude that exports generalized list functions (for example BasicPrelude's intercalate which works on monoids) and good text conversion functions (text -> ltext -> bytestring -> lbytestring). What should I look into?
<literallyCrevice>	If it doesn't have any partial functions that's a plus, but not certainly required.
<crestfallen>	thanks EvanR dmwit .. if I could go back real quick..
*	paulasdf has quit (Ping timeout: 250 seconds)
*	M0b10s has quit (Ping timeout: 250 seconds)
*	gxt has quit (Ping timeout: 260 seconds)
*	hiptobecubic (~john@unaffiliated/hiptobecubic) has joined
<crestfallen>	so " understand all this by considering Maybe as a list with at most 1 element "
<crestfallen>	...
<EvanR>	pretty much
*	lprd_ has quit (Ping timeout: 250 seconds)
<crestfallen>	> (<$>) (foldr (+) 0) [(Just 4.5), (Just 2), (Just 3.3)]
<lambdabot>	 [4.5,2.0,3.3]
<EvanR>	> (<$>) (foldr (+) 0) [[4.5], [2], [3.3]]
<lambdabot>	 [4.5,2.0,3.3]
<MarcelineVQ>	for lists <$> is map, if that's at all clarifying
<crestfallen>	so (<$>) maps over the Maybe elements, but the (foldr (+) 0)  doesn't return an error, but it's not at all being utilized, right?
*	thelounge409 (57ac5683@gateway/web/thelounge/ip.87.172.86.131) has joined
<jle`>	> foldr (+) 0 (Just 10)
<lambdabot>	 10
<jle`>	crestfallen: foldr (+) 0 is total, it cannot return an error
*	dhil (~dhil@dhcp-90-108.inf.ed.ac.uk) has joined
<jle`>	maybe you are thinking about whether or not it typechecks?
*	wroathe has quit (Read error: Connection reset by peer)
<jle`>	> foldr (+) 0 Nothing
<lambdabot>	 0
*	toppler has quit (Ping timeout: 240 seconds)
<jle`>	crestfallen: (<$>) in your example maps over the list
*	thelounge409 has quit (Client Quit)
<jle`>	> map (foldr (+) 0) [Just 4.5, Just 2, Just 3.3, Nothing]
<lambdabot>	 [4.5,2.0,3.3,0.0]
<EvanR>	crestfallen: did you see how my example was just yours with Just 4.5 replaced with [4.5]. This is all you're doing. Sum of 1 thing
<jle`>	oh it looks like i stumbled into a long conversation
*	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined
<jle`>	> sum Nothing
<lambdabot>	 0
<jle`>	> sum (Just 3)
*	Rudd0 (~Rudd0@185.189.115.103) has joined
<lambdabot>	 3
<xsperry>	> catMaybes [Just 1, Nothing, Just 2]
<lambdabot>	 [1,2]
<jle`>	> map sum [Nothing, Just 3]
<lambdabot>	 [0,3]
*	Rudd0^ (~Rudd0@185.189.115.103) has joined
<crestfallen>	yeah ok thanks ALL it is being utilized but it returns the sum of each Maybe element which is just itself
<jle`>	crestfallen: yeah, or 0 if it is Nothing
<jle`>	sum is polymorphic for all Foldable containers
<jle`>	:t sum
<lambdabot>	(Foldable t, Num a) => t a -> a
<jle`>	that's why saying things like 'the Maybe functor' is misleading unless you are actually talking about the functor properties itself
<EvanR>	we returned to the beginning of the convo. Maybe this is a good time to end it :)
<jle`>	when you do `map sum [Just x, Just y, Nothing]`, it isn't "summing over the functor values"
<jle`>	it's summing every "foldable" value
<xsperry>	I don't hear "Maybe functor" nearly as often as "Maybe monad"
<jle`>	just because you see Maybe/Nothing/Just, doesn't mean that Functor is important
<EvanR>	i want to hear about functors more often
<crestfallen>	right. simple enough.
<jle`>	'map sum' will map sum over the *foldable* elements in the list. and here we have the Maybe Foldable
<crestfallen>	you will be EvanR :)   I'm giving myself a month to fully understand them before I move on to applicative
<jle`>	note that sum works even for types that aren't Functor
<jle`>	> sum (S.fromList [1,2,3])
<lambdabot>	 6
<jle`>	(Set is not a Functor)
<jle`>	so 'functor' isn't the important concept being used here, but rather Foldable
*	Azel has quit (Quit: Azel)
<crestfallen>	copy that, thanks everyone that is deep
<EvanR>	i want to hear about haskell's functorial IO system
<EvanR>	haskell IO runs on functors
<EvanR>	hehe
*	doublex has quit (Ping timeout: 264 seconds)
*	fphilipe has quit (Ping timeout: 240 seconds)
<crestfallen>	> map (foldr f z) [Nothing, Just x]
<lambdabot>	 [z,f x z]
<dminuoso>	crestfallen: I think Applicative has a misleading signature method which somewhat contributes to its confusion.
*	chaosmasttter (~chaosmast@p200300C4A72E47010000000000000001.dip0.t-ipconnect.de) has joined
<crestfallen>	especially that interests me ^ because..
<crestfallen>	I thought to operate on Maybe at all, we would need <$>
<merijn>	crestfallen: Why?
<jle`>	yeah, that's definitely a consequence of thinking about 'maybe monad', and definitely wrong :)
<jle`>	crestfallen: you can always just pattern match
<merijn>	crestfallen: "case Just 3 of Nothing -> "foo"; Just x -> show x"
<jle`>	> map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x]
<lambdabot>	 [z,f x z]
<jle`>	(<$>) is a useful function that we build on *top* of pattern matching
<dminuoso>	crestfallen: The Functor interface is merely the observation that "mapping over something with a function, changing its type along side" is something we do frequently.
*	albertus1 (~seb@x4d0cbea3.dyn.telefonica.de) has joined
<dminuoso>	crestfallen: So <$> just captures that pattern. :)
<jle`>	it isn't a primitive action, but rather a useful handy shortcut
<jle`>	over pattern matching
<xsperry>	crestfallen, do you need <$> to operate on a list?
<jle`>	do you need (==) to operate on Int?
*	knupfer has quit (Ping timeout: 264 seconds)
*	toppler (~user@mtop.default.momentoftop.uk0.bigv.io) has joined
<jle`>	ah sorry if that came off as dogpiling :)
<crestfallen>	geez I cannot process all that
<jle`>	actually it's funny, for a while in java, they actually forbade people from defining <$> for Maybe
<dminuoso>	crestfallen: I like to think of Applicative of actually having the shape `class Functor f => Monoidal f where (<+>) :: f a -> f b -> f (a, b); unit :: f ()` which hints that what this is actually about, is combining "effects two effects and just grabbing both results alongside"
<EvanR>	crestfallen needs some to process
<EvanR>	some time
<jle`>	Java introduced option, and people were like "hey let's write a function to map over the contents, instead of manually 'pattern matching' and handling the cases"
<jle`>	and the java people were like "no you can't do that"
<jle`>	"wait that's illegal"
*	heatsink (~heatsink@2600:1700:bef1:5e10:f1ca:43ba:7c4b:388f) has joined
<jle`>	so that would be like someone proposing to add <$> for Maybe to the standards library and people rejecting it
<EvanR>	how do java people go about stopping you from writing a function
*	knupfer (~Thunderbi@200116b824652c00f69634fffef0b45f.dip.versatel-1u1.de) has joined
<jle`>	i exaggerated some bits for my story :)
<jle`>	but it was proposed to add to the standard interface for Option
<EvanR>	ah
<EvanR>	and it was illegal?
*	wroathe (~wroathe@23-30-253-203-static.hfc.comcastbusiness.net) has joined
<jle`>	so the moral of the story is that we are very lucky to even have <$> at all
<jle`>	for Maybe
<jle`>	a lot of people have to make do without it
<merijn>	EvanR: You need to step up your meme game
*	doublex (~doublex@2601:542:c480:6ee0:604d:2b77:50e6:a474) has joined
<crestfallen>	 > map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x
<crestfallen>	I'm still working on this
<EvanR>	oh god... are there memes around
<merijn>	EvanR: https://knowyourmeme.com/memes/wait-thats-illegal
*	vpeurala_ has quit (Ping timeout: 246 seconds)
<crestfallen>	> map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x
<lambdabot>	 <hint>:1:59: error:
<merijn>	EvanR: Memes are everywhere, man
<lambdabot>	     parse error (possibly incorrect indentation or mismatched brackets)
<dminuoso>	jle`: I think the point is not even to have <$> for Maybe, but rather a polymorphic interface such that Maybe is an acceptable choice for Functor.
<crestfallen>	> map (\case Just x -> f x z; Nothing -> z) [Nothing, Just x]
<lambdabot>	 [z,f x z]
<dminuoso>	Because merely mapping over it with fmap is relatively boring, at the end.
*	cr3 has quit (Quit: leaving)
<merijn>	EvanR: Just look: http://lambdacats.org
<jle`>	dminuoso: the debate was actually against having a mapping function at all for Maybe
<merijn>	aww
<dminuoso>	jle`: really. :S
<merijn>	EvanR: Looks like someone took it down :(
<jle`>	yeah, the argument was "we don't want people to start saying that Maybe is a functor. and then too much jargon."
<jle`>	"prevent elitist FP jargon from entering java"
<EvanR>	i have been told that using a functional pattern like that was stupid because of the overhead
<EvanR>	use an if then else instead like everyone else, and it's faster
<dminuoso>	jle`: Amusingly it wouldn't even be elitists entering Java. Those masochist people actually embracing the idea of having small functional tools on the JVM are already off to Scala, so they shouldn't be worried!
<dignissimus>	I have a list of moves and also have function that can map these moves to values, I want to get the move with the largest value, my first idea was `head . sortBy valueFunction`, is that ok?
<jle`>	there was actually a solid technical reason that i am omitting for the sake of a cheeky story
<crestfallen>	One day I will use elistist FP jargon :)
*	heatsink has quit (Ping timeout: 250 seconds)
<EvanR>	jle`: oh good, for a minute i thought i was learning something true about java :)
<jle`>	dignissimus: just be careful of getting an empty list
*	LKoen has quit (Remote host closed the connection)
<jle`>	i mean, from an elitist FP jargon standpoint, there is a reason to not have an fmap for java Option
<jle`>	it's because Java Option cannot hold null
<dminuoso>	jle`: Something to do with "higher kinded" polymorphic functions being impossible?
<jle`>	so fmap (f . g) = fmap f . fmap g won't hold if g returns null
<EvanR>	you can say you're writing "morally correct" java
<dminuoso>	See, non-lawful Functor, all elitist FP would stay far away from Java. 
<dminuoso>	Job done.
*	LKoen (~LKoen@81.255.219.130) has joined
<crestfallen>	jle`, so the pattern matching, it's like it's forced since it doesn't use <$> .. because it doesn't need to. but I guess it doesn't need to ever.
*	comerijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined
<jle`>	crestfallen: yeah, you don't ever *need* Functor/Applicative/Monad/Foldable/Traversable/Monoid/Semigroup/Eq/Ord/etc. ever for Maybe, because you can always just pattern match
*	Lycurgus (~niemand@98.4.103.219) has joined
<jle`>	(with exceptions for the cases where you feed a Maybe to a function that is polymorphic on all instances of a typeclass, like using 'sort' on a list of maybes)
*	slack1256 has quit (Remote host closed the connection)
*	turab has quit (Ping timeout: 240 seconds)
*	turab (~turab@2001:18e8:2:28b7:f000::1eed) has joined
*	carlomagno has quit (Ping timeout: 240 seconds)
<jle`>	it just makes it convenient to be able to write `x == y`, instead of case x of Nothing -> case y of {Nothing -> True; Just _ -> False}; Just x' -> case y of {Nothing -> False; Just y' -> x == y}
<jle`>	* x' == y' at the end
*	carlomagno (~carlomagn@inet-hqmc06-o.oracle.com) has joined
*	cosimone (~cosimone@2001:b07:ae5:db26:9520:741c:a5e9:2223) has joined
*	comerijn has quit (Ping timeout: 268 seconds)
<xsperry>	> Just 10 == Just 10   -- :)
<lambdabot>	 True
<crestfallen>	ok thanks again. I'm going to clean my venetian blinds now :)
