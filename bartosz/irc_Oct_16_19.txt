
I'm looking at the definition of semigroup which says: "A semigroup 
generalizes a monoid in that there might not exist an identity element. 
It also (originally) generalized a group (a monoid with all inverses) 
to a type where every element did not have to have an inverse, thus 
the name semigroup." 

The problem is that without that superclass you can define monoids which are not semigroups, which means you can't generalise monoid code to semigroup code without that superclass. There's not technical reason semigroup has to be a superclass of Monoid. You could define instances for both before that was the case
What the superclass gets you is the guarantee that *every* Monoid also has a Semigroup instances

Ok I see. monoid has a "single most natural operation for combining values" which is different from a binary operator, correct? so foldr for example, also doesn't need to apply a binary operator necessarily to the list

Because the proper definition of a monoid is "an associative binary operation + identity element"

The laws of Monoid (the Haskell class and also the math notion) are as follows: 

1) "mappend a (mappend b c) == mappend (mappend a b) c" 
2) "mappend mempty x = x = mappend x mempty"

Mappend *is* a binary operation, not just technically
-- > foldr not Bool [True,False,True]
Oct 16 12:21:20 <lambdabot>	 error:
Oct 16 12:21:20 <lambdabot>	     • Data constructor not in scope: Bool
Oct 16 12:21:20 <lambdabot>	     • Perhaps you meant variable ‘bool’ (imported from Data.Bool)
Oct 16 12:21:31 <crestfallen>	sorry what should the seed value be there?
Oct 16 12:21:41 <dmwit>	can't be made to work
Oct 16 12:21:52 <dmwit>	not is unary, foldr needs a binary operation
Oct 16 12:22:28 <crestfallen>	dmwit dang I thought I was working with that a while back

There's two monoids on Bool (well, actually a lot more, but two common/oft used ones)
But since you can only have one instance per type you need newtypes to use them
Which in this case are Any and All

-- > foldMap Any [True, False, True, False]
<lambdabot>	 Any {getAny = True}

-- > foldMap All [True, False, True, False]
All {getAll = False}

ok thanks I was thinking of a snippet I was working on, where the seed was True or Bool, like a snippet to illustrate boolean logic
so the difference b/t foldable and monoid is that foldable needs no identity

(There are four monoids on Bool: (&&)/True, (/=)/False, (==)/True, (||)/False. These correspond to making two independent choices: either Sum or Product, and which of False/True represents 0/1.)

<merijn> (First and Last)
<dmwit>	There are 8 semigroups.
(besides First and Last, there's const False and const True)

Lets rewind, how'd you end up with these questions? Because perhaps you don't need to know the answer right now :)
<boxscape>	dmwit so const False and const True are Semigroup but not Monoids?
Oct 16 12:40:12 <crestfallen>	I was trying to get one point straight, then other questions came up, then your input made me wonder about various foggy areas
<dmwit>	boxscape: right
Oct 16 12:41:04 <boxscape>	dmwit why can't you just set mempty to True for const True and False for const False?
Oct 16 12:41:39 <boxscape>	wait I should probably just look at the identity laws huh
Oct 16 12:42:07 <dmwit>	boxscape: No matter what mempty you pick, mempty <> False = True, which isn't okay.
Oct 16 12:42:15 <boxscape>	okay, that makes sense
Oct 16 12:42:27 <dmwit>	(Sorry, I meant const (const False) and const (const True), of course.)
Oct 16 12:47:49 <crestfallen>	merijn, I'm trying to get it from the math side as well so I've been reading about these different structures

hey how do you make the little bullet to make clever little comments under your handle in say hexchat? like: crestfallen nods
in hexchat you type /me nods
*	crestfallen nods
*	sm[m] high-fives crestfallen
*	crestfallen hip hip hooray!

A mathematician would never use prefix application to demonstrate associativity.
It was just a small joke about merijn's statement about the "math motion" contrasted with his Haskell notation.
I see you don't like prefix notation like "mappend a (mappend b c) == mappend (mappend a b) c"  . I studied scheme for a minute and got used to prefix notation so I often prefer it. it's weird how sometimes it just looks wrong, other times clean.
