15:39 crestfallen: > pure 5 :: [Int]
15:39 lambdabot:  [5]
15:39 crestfallen: hi why do I need to specify the type here?
15:40 crestfallen: > pure 5
15:40 lambdabot:  error:
15:40 lambdabot:      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M566981383817...
15:40 lambdabot:        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
15:40 hpc: what should it show?
15:40 hpc: > pure 5 :: Maybe Int
15:40 lambdabot:  Just 5
15:40 hpc: > pure 5 :: IO Int
15:40 lambdabot:  <IO Int>
15:41 hpc: > pure 5 :: (Int -> Int)
15:41 lambdabot:  mueval-core: Time limit exceeded
15:41 crestfallen: the instance declaration for applicative []  is pure x = [x]
15:42 hpc: why should it look at that instance in the first place?
15:42 crestfallen: I dont know
15:42 boj: :t pure
15:42 lambdabot: Applicative f => a -> f a
15:42 hpc: it could pick any of the others i showed
15:43 hpc: or ones that your module doesn't even know about yet
15:43 boj: there's no way it can know what f you are talking about
15:44 hpc: fun fact: this happens all the time
15:44 crestfallen: what does
15:44 hpc: ambiguous type variables
15:44 hpc: :t 5
15:44 lambdabot: Num p => p
15:44 hpc: > 5
15:44 lambdabot:  5
15:45 hpc: here it doesn't know if it should be Int or Double or Complex or Rational or what
15:45 hpc: but only for numbers, the type gets defaulted
15:45 hpc: if it's Num p, it picks Int (or Integer?)
15:45 hpc: if it's Floating p, it picks DOuble
15:46 hpc: > 5.0
15:46 lambdabot:  5.0
15:46 hpc: :t 5.0
15:46 lambdabot: Fractional p => p
15:46 crestfallen: hpc yeah somehow I thought it defaults to List but there's no reason for that
15:46 hpc: ah, Fractional
15:46 hpc: there are extended defaulting rules
15:46 hpc: but i think that just means as a last ditch effort pick ()

15:47 crestfallen: oh my namesake I see :)
15:47 crestfallen: great word, too pretty to change though I'm essentially an eternal optimist
15:48 hpc: i thought it came from a tragic toothpaste accident ;)
15:48 crestfallen: hpc that's funny

16:39 crestfallen: https://paste.ee/p/awVqE

      If you remove the `pure` there, it will fail to typecheck.

      pure x = [x]

      pure takes a function, say, (*)
      and give us this [(*)]
      
      now look at the thing that's using [(*)]
16:48 crestfallen: [(*)]   ?
16:48 hpc: and consider what other values you could use besides [(*)]
16:48 hpc: what if the list was empty?
16:48 hpc: what if it had two different functions in it?
16:49 hpc: (<*>)
16:50 crestfallen: what if it had two different functions in it?      
16:50 jle`: [(*),(+)]
16:51 jle`: crestfallen: pure x takes x and returns [x]
16:51 jle`: so pure (*) takes (*) and returns [(*)]
16:51 jle`: just like how pure 1 takes 1 and returns [1]
16:51 jle`: it doesn't really convert 1 into anything, all it does is put it in a list
16:51 crestfallen: so <*> is operating inside that initial list which contains the (*)    ie [(*)]     ?
16:52 jle`: yeah, (<*>) is a function that takes two lists, and does stuff with the items in both lists
16:52 crestfallen: so it might look like this   [[1,2,3] <*> (*) <*> [10,20]] or something   ?
16:53 jle`: not sure what "it" means here or what you are trying to give an example of
16:53 hpc: take the ghci line in your paste
16:53 hpc: and experiment with the start of it, where you pass the function(s)
16:54 jle`: crestfallen: (<*>) for lists is defined so that [f,g,h] <*> [x,y,z] = [f x, f y, f z, g x, g y, g z, h x, h y, h z]
16:54 jle`: > [f,g] <*> [x,y] :: [Expr]
16:54 lambdabot:  [f x,f y,g x,g y]
16:54 crestfallen: that much I understand
16:55 jle`: > [negate] <*> [1,2,3]
16:55 lambdabot:  [-1,-2,-3]
16:55 jle`: > pure negate <*> [1,2,3]
16:55 lambdabot:  [-1,-2,-3]
16:55 jle`: pure negate is just a fancy way of writing [negate]
16:55 crestfallen: ok so the function (*) just sits in the first place with its own <*>   ie..
16:56 jle`: do you understand `pure negate <*> [1,2,3]` ?
16:56 crestfallen: [(*)] <*> [1,2,3] <*> [10,20]
16:56 jle`: yeah, that's what pure (*) <*> [1,2,3] <*> [10,20] turns into

      jle`: because in haskell you can always replace function calls by their definitions

      hpc: the value of pure here is, what if you're not operating on lists

      jle`: and pure x = [x], so you can replace `pure (*)` with `[(*)]`

      jle`: also probably important, you should know how (<*>) associates
      jle`: fs <*> xs <*> ys is associated as (fs <*> xs) <*> ys
   
      crestfallen: that's interesting . its simply that using <*> each operand needs to be of the same type : [(*)] , [1,2] etc

      jle`: well, both sides of <*> have to have the same 'f' (Applicative instance), but the parameter to f doesn't 
      have to be the same necessarily

      jle`: consider the case of [negate] <*> [1,2,3], where the left hand side is [Int -> Int] and the right hand side is [Int]
      jle`: :t id id

      lambdabot: a -> a

17:00 crestfallen: ok yeah so bottom line is line 3 produces [(*)] .. oh reading those last posts...
17:02 crestfallen: that's like  '  fmap id = id      id on each side has a different type
17:03 crestfallen: fmap id    would give    f a -> f a  on the rhs

      jle`: well, the equals sign there doesn't quite mean anything in haskell; but yeah it's a generally accepted convention 
      that the things on both sides of an equal sign are meant to be equal as a notational convention

17:05 jle`: when someone says "fmap id = id" as a law, it's not quite something that exists using that syntax in haskell
17:05 crestfallen: well I guess it means that the a is preserved, but its now inside the f :  '  f a  '
17:05 jle`: but they are trying to convey that "fmap id" and "id" should be replaceable with each other within a program
17:06 crestfallen: that last comment of yours I would love to see an example..

17:06 jle`: well, the statement "fmap id = id" is a non-haskell-syntax statement that you should be able to replace "fmap id" 
      with "id" (and vice versa) within a program without changing the meaning

17:06 jle`: that's what the equals sign there means, when people talk about it as a law
17:06 jle`: they don't actually mean to refer to any '=' syntax within haskell, it's more of an informal human-level statement

17:07 jle`: crestfallen: yeah, the law says that if you ever see 'fmap id x' in a program, you can just replace it with 'id x' without changing the meaning

17:07 crestfallen: it means that the a -> a part is preserved, but its in a context now

17:07 jle`: for example if i ever saw someone write "fmap id [1,2,3]", i would say "why are you writing fmap id [1,2,3], don't you know about the functor laws? you can just write 'id [1,2,3]'. which is just [1,2,3]"

17:08 crestfallen: right, the fmap just falls off whenever you see id [1,2,3]
17:08 jle`: crestfallen: well remember that fmap id [1,2,3] is associated as (fmap id) [1,2,3]
17:08 jle`: so it means that (fmap id) is just (id)
17:09 pyan: And rightfully “undefined == undefined” returns neither True nor False.

17:10 jle`: crestfallen: so my point is that, when someone says "blah = blahblah", the implication is yes, blah and blahblah have 
the same type. because they are meant to be interchangeable with each other

17:10 crestfallen: jle`: if I could extend this idea.. is this like the combinators id flip const    and all that business?
17:11 jle`: things like const id = flip const ?
17:11 jle`: yeah, the = there as i use it has the same meaning
17:11 crestfallen: > fmap id [1,2,3]
17:11 lambdabot:  [1,2,3]
17:12 crestfallen: > const id 5
17:12 iqubic: :t const id
17:12 lambdabot:  mueval-core: Time limit exceeded
17:12 lambdabot: b -> a -> a
17:13 crestfallen: > const id 5 "t"
17:13 lambdabot:  "t"
17:15 crestfallen: so what I don't see is why these seem to be important combinators :    const id flip        ie. I read little tutorials about them but don't really see how they work in programs
17:16 jle`: their definitions are pretty simple, so "how they work" isn't too tricky, is it?
17:16 jle`: const x y = x, const just ignores the second argument
17:16 jle`: id x = x, it just returns its argument as-is
17:16 crestfallen: yeah but first off, why are they combinators? I mean, whats a combinator?
17:17 crestfallen: const ignores the 2nd arg, is that for say currying?
17:17 jle`: combinator doesn't really mean anything formal, the most general sort of meaning they evoke is that they can be used to build complicated things from simple building blocks
17:17 jle`: in haskell they usually just mean "higher order functions"
17:18 crestfallen: does that tie into SKI calculus ?
17:18 jle`: a lot of times when working with higher order functions in haskell, you only really need to pass in simple functions
17:19 crestfallen: like where would you pass in const say?
17:19 jle`: for example a lot of people use const to replace the result of a Functor value
17:19 jle`: > map (const ()) [1,2,3,4]
17:19 lambdabot:  [(),(),(),()]
17:20 jle`: this is in the standard libraries as "void"
17:20 jle`: or you can use it with, say, zipWith to ignore items in the second list and only use items in the first list
17:20 jle`: > zipWith const [1,2,3] [4,5]
17:20 lambdabot:  [1,2]
17:20 jle`: i don't think there is any "big picture" overall idea that unites all usages of const
17:21 crestfallen: the zipWith example...
17:21 crestfallen: what happened there?
17:21 jle`: it's just that (\x _ -> x) comes up here and there often enough in different places for different usages that it's useful enough to justify giving it a common name
17:21 jle`: well zipWith f [x,y,z] [a,b] = [f x a, f y b]
17:21 jle`: it just zips the values in two lists together, using a combining function
17:22 jle`: but if you only care about the items in the first list...then you can do something like zipWith (\x _ -> x) [1,2,3] [4,5]
17:22 jle`: it's not like this is a fundamental deep and powerful property of const
17:22 jle`: it's just that 'const' takes less characters than (\x _ -> x)
17:22 comerijn has joined (~merijn@83-160-49-249.ip.xs4all.nl)
17:22 jle`: and is probably more readable :)
17:23 crestfallen: > zipWith const [1,2,3,4] [4,5] 
17:23 lambdabot:  [1,2]
17:23 jle`: ah yeah also remember that zip drops the items from the longer list
17:23 jle`: > zip [1,2,3,4] [4,5]
17:24 lambdabot:  [(1,4),(2,5)]
17:24 crestfallen: ok yeah
17:24 jle`: so this is not some deep mystical property of const
17:24 jle`: if you wanted to do this you might just write zipWith (\x _ -> x)
17:24 jle`: and if you wanted to replace all the items in a list with () you might just do map (\_ -> ()) [1,2,3]
17:24 crestfallen: so even though [4,5] is dropped, the first list reflects the number of elements
17:25 crestfallen: of the lesser list
17:25 jle`: it's just that when you work with higher order functions enough times, similar functions pop up here and there and it's common enough that it's useful to give them names for readability
17:26 crestfallen: thanks jle` kindly. are my last 2 posts correct 
17:26 crestfallen: ?
17:26 jle`: the values 4 and 5 are dropped
17:26 jle`: but the shape of the list (the length) persists
17:26 crestfallen: so zip chooses the first 2 elements of [1,2,3,4] ?
17:26 ignace has joined (~braden@218.158.95.253)
17:27 jle`: yeah, it matches the elements until it runs out on either list
17:27 jle`: @src zip
17:27 lambdabot: zip (a:as) (b:bs) = (a,b) : zip as bs
17:27 lambdabot: zip _      _      = []
17:28 crestfallen: actually sometimes I find elemental functions like this hard to get.
17:28 crestfallen: appreciate it ! jle`
17:28 boj: > zipWith (+) [1,2,3,4] [9,8]
17:28 lambdabot:  [10,10]
17:29 jle`: no problem :)
17:29 jle`: i don't mean to give the definition to show that it is simple/elementary, but rather to give you the tools to be able to work through the conclusion yourself :)
17:29 crestfallen: no I wasn't referring to the definition you gave
17:30 crestfallen: but in the case of using zipWith const   ...
17:30 crestfallen: still ..
17:30 crestfallen: if you drop the second list
17:31 crestfallen: you are ' matching the elements '   ,  really just the first two elements of the first list, given the number of elements in the 2nd list? what good is that?
17:31 crestfallen: > zipWith const [1,2,3,4] [4,5]
17:32 lambdabot:  [1,2]
17:32 jle`: small random things like this come up all the time in everyday program
17:32 jle`: so this question is like "if you add two to 56, you get 58 ... what good is that?"
17:32 jle`: *everyday programming
17:32 crestfallen: :) !!
17:32 jle`: it's not like "what good is adding 3 to a number?" has a real answer
17:32 Axman6: "I need these lists to be the same length because I'm making an HTML table, and I don't want to use length because it's unnecessarilly strict"
17:33 kinouchou has joined (~kinouchou@178.162.204.238)
17:33 jle`: it's just ... sometimes you need to add something, and sometimes it's just three
17:33 crestfallen:  no but it is not zipping, those elements are just at index 0,1 of the first list
17:33 jle`: yeah, it can be useful for limiting your lists to a given length
17:33 Axman6: \row ->  zipWith const row headers -- will ensure the row is the same length as the list of headers, or less
17:34 jle`: so if i had headers = ["Color", "Length", "Weight"]
17:34 jle`: then zipWith const myRow headers will limit myRow to the number of items that headers has
