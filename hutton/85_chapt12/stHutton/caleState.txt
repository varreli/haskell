 <Cale> In order to be able to build up some abstraction around this though, we'λ  use a newtype:
 <Cale> newtype State s a = S (s -> (s,a))
 <Cale> and because of our choice of representation, the function to run such a thing on an initial state and get the final state and result will be super-easy:
 <Cale> runState :: State s a -> s -> (s,a)
 <Cale> runState (S f) s = f s
 <Cale> or simply:
 <Cale> runState (S f) = f
 <crestfallen> thanks I'm comparing that to some other stuff I have
 <Cale> We can also build that into the definition of the type, by making use of the fact that if we use record syntax, we automatically get functions which extract the fields:
 <Cale> newtype State s a = S { runState :: s -> (s, a) }
 <Cale> This will automatically define the field extractor function, which will take a value of type State s a, and extract the field of type s -> (s,a) from it
 <Cale> i.e. runState :: State s a -> s -> (s,a) as before
 <crestfallen> field extractor and record syntax, actually terms I'm new to..
 <Cale> That part isn't essential
 <crestfallen> I've seen newtype State s a = S { runState :: s -> (s, a) }  before
 <Cale> Right, so that defines it as a record having one field called runState
 <Cale> and as such, you automatically get a function called runState which will extract the field from the record
 <Cale> Just as if you'd defined  data Employee = Empl { name :: String, salary :: Int }
 <Cale> it'd automatically define  name :: Employee -> String
 <Cale> and  salary :: Employee -> Int
 <crestfallen> so yeah State is dawning on me over time, even with the dummy constructor and then defining app to rid us of the dummy constructor...     yes, those last posts are helpful
 <crestfallen> so the field is the entire tuple , (s,a) correct?
 <Cale> No, it's a function of type s -> (s,a)
 <crestfallen> one moment please
 <Cale> no problem
 <crestfallen> so the note I have at the top of module StateMod, "Many things in haskell are just complicated ways to talk about state"
 <crestfallen> I worked with s.ki on a ticker program, let me fetch it...
 <crestfallen> http://ix.io/2qK5
 <crestfallen> so I see how those functions work (tick, ticker, evenTick) however ...
 <crestfallen> I don't quite understand the purpose of them, particularly ticker
 <crestfallen> evenTick is straightforward..
 <Cale> Well, all this is of limited usefulness, but eventually it'λ  be a building block for useful things
 <crestfallen> ok, yeah , how ticker returns ([5,6,7],8) there is cool, but I'm not too clear on the purpose
 <Cale> Our first goal will be to get away from having to use the S constructor by building up enough basic operations for reading and writing the state and chaining together actions of type State s a
 <Cale> So, we might start with get and put
 <crestfallen> ok, warning never used get and put :)
 <Cale> get :: State s s  will be a computation which won't affect the current state (i.e. its final state will be the initial state), but will have that state as its result as well
 <Cale> Want to try writing it?
 <crestfallen> s -> (s,s)
 <crestfallen> runState :: s -> (s,s)
 <Cale> Uhh, that'λ  be the type of the runState field
 <crestfallen> tick = S (\n -> (n,n))
 <Cale> Or you mean  get = S (\n -> (n,n)) ?
 <Cale> Yeah, that'λ  do it
 <Cale> We don't have many ways yet to make values of type State s a apart from using S
 <Cale> So, we might as well use it:
 <Cale> get = S ...
 <crestfallen> nontick :: ST Int; nonTick = S (\n -> (n,n))
 <Cale> and then, in this case, its argument has type s -> (s,s), so it might as well be a lambda
 <Cale> get = S (\s -> ...)
 <Cale> and then we have a value s :: s, and we want to produce a pair of type (s,s), so there's one obvious thing to do
 <Cale> get = S (\s -> (s,s))
 <Cale> To go along with that, we'λ  want  put :: s -> State s ()
 <crestfallen> So the () is that like unit?
 <Cale> which, given a value of type s, will produce the State action that, no matter what value the initial state was, will set the current state to the given value
 <Cale> (and produce an empty tuple)
 <crestfallen> is that related to:    f = runState (return 'X') 1
 <crestfallen> ('X',1)
 <Cale> In what way?
 <crestfallen> well, first of all, are we on (a,s) or (s,a)  ?
 <crestfallen> sorry I don't know what's happening
 <Cale> Well, I gave the definition newtype State s a = S (s -> (s,a))
 <Cale> But obviously, it doesn't really matter which order the pairs are in, so long as we know which way around they go
 <crestfallen> ok thanks, so far in the hutton code, what corresponds with get and put?
 <Cale> I doubt Hutton calls them any differently
 <crestfallen> in the section on applicatives/monads, I haven't come across get/put yet
 <Cale> That's fine
 <Cale> I'm introducing them
 <crestfallen> ok
 <Cale> Want me to write put?
 <crestfallen> Cale re: your above comment " Our first goal will be to get away from having to use the S constructor by building up enough basic operations for reading and writing the state and chaining together actions of type State s a "
 <Cale> yeah
 <crestfallen> ok so..
 <Cale> So, get will be a thing that "reads" the current state, and put will be a thing that "writes" it
 <crestfallen> hutton is using a state transformer with this construction S the dummy constructor
 <crestfallen> are we trying to not use the ST model?
 <Cale> I introduced everything we need
 <Cale> I'm not using his stuff
 <crestfallen> ok
 <crestfallen> ok
 <Cale> It's very very similar though
 <crestfallen> because many folks don't like the ST business, since it looks like other stuff
 <crestfallen> btw I didn't mean "ok so" as in "so what".. I was continuing my train of thought..  :)
 <Cale> Shall I write put, or do you want to try?
 <crestfallen> one moment please..
 <crestfallen> a hint please Cale, am I working on something similar to execState ?
 <crestfallen> as in : State s a -> s -> s
 <Cale> no
 <Cale> put :: s -> State s ()
 <Cale> and the goal is that after running  put v  the final state will be v, regardless of what the initial state was
 <crestfallen> put val = S (\s -> (val,val))
 <crestfallen> put s val = S (\s -> (val,val))
 <Cale> The first one is close
 <Cale> But remember that the result is supposed to have type State s ()
 <Cale> So, the result has to be ()
 <Cale> The new state indeed can be val like that
 <Cale> and s, the initial state, is ignored
 <crestfallen> put val = S (\s -> ((),val))
 <crestfallen> :(
 <Cale> That uses the opposite convention from the one I went with, but sure
 <crestfallen> put val = S (\s -> (val, ()))
 <Cale> yeah
 <crestfallen> phew
 <Cale> So, now, we also want a way to produce an action which "does nothing" except to have a given value as its result
 <Cale> return :: a -> State s a
 <Cale> will be the computation which does nothing to the current state (i.e. the final state will be the same as the initial state), but has the given value of type a as its result
 <crestfallen> give g = S (\s -> (g,s))   
 <crestfallen> :(
 <Cale> If you prefer the convention where the state is second, we can just use that
 <Cale> But yeah
 <Cale> So, now we have the more interesting part:
 <crestfallen> very sorry no:
 <crestfallen> give g = S (\s -> (s,g))   
 <Cale> yeah
 <crestfallen> appropriate name?
 <Cale> It's reasonable
 <crestfallen> phew thanks
 <crestfallen> lord I find state very tough
 <Cale> The reason I used the name 'return' is that is actually the name we end up using
 <Cale> But if you want to define that, you'λ  have to write an instance of the Monad type class
 <crestfallen> right I was going to use retuurn
 <Cale> instance Monad (State s) where
 <Cale>   return v = ...
 <Cale>   x >>= f = ...
 <Cale> We're about to do (>>=) now :)
 <crestfallen> well it's the opposite of execState State s a -> s -> s
 <crestfallen> I guess
 <Cale> If you want, I'λ  just walk through that one step by step, since it's a little more challenging, or if you'd prefer, I can give you the type signature and English description again
 <Cale> Well, I'λ  do that anyway
 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
 <Cale> The idea is that x >>= f will be the State s b action which, when run, will first run x on the initial state, producing some intermediate state, and then if the result of that is v
 <Cale> it will then run (f v) on the new intermediate state, producing some final state and result which will be its own final state and result
 <Cale> So, it's like we run x, and get to use its result somehow to decide what to do next
 <Cale> and f is the function which tells us what to do next based on the result of x
 <Cale> Make sense?
 <Cale> So, for example
 <Cale> get >>= \n -> put (n+1)
 <Cale> will be the action which increments the current state
 <crestfallen> ok
 <Cale> So, let's think through this step by step
 <Cale> x >>= f = ...
 <Cale> Well, we might as well use the S data constructor, since none of the things we've written so far look much like this :)
 <Cale> x >>= f = S ...
 <Cale> and that wants a function which takes the initial state, and is going to ultimately produce a pair of the final state and result
 <Cale> x >>= f = S (\s -> ...)
 <Cale> and now we said, we want to first run x :: State s a on the initial state. When we do that, we'λ  get some new state and result, so let's give those names:
 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; ...)
 <Cale> So s' is our new state, and v is the result of running x
 <Cale> and then we wanted to run (f v) on the new state, getting some final state and result
 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; (s'', w) = runState (f v) s' ...)
 <Cale> So we get s'', the final state, and w, the result of running (f v)
 <Cale> and then lastly, we produce those as our own final state and result:
 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; (s'', w) = runState (f v) s' in (s'', w))
 <crestfallen> but with S, isn't this precisely like the ST technique?
 <Cale> Yeah, this is the same stuff, the names are just different
 <crestfallen> here's the thing, in     instance Monad ST where      ...
 <crestfallen> in my code paste ..
 <Cale> (oh, and we're parametric on s)
 <crestfallen> app in written into the instance
 <Cale> Yeah, I don't know why he called it app
 <crestfallen> st >>= f = S (\s -> let (x,s') = app st s in app (f x) s')
 <Cale> Maybe because he's thinking in terms of applying the function
 <Cale> Yeah, that's the same thing as we just did, pretty much
 <crestfallen> however app must be applied in the do notation version of mlabel (for the Tree structure)
 <crestfallen> where at the bottom of the paste I have monadLab = app (mlabel tree) 4
 <crestfallen> so that is causing me some confusion
 <crestfallen> re: app, you said above "  he's thinking in terms of applying the function " .. which function are you referring to?
 <jusss`> there's a list [1,2,[3,4],[3,[5,6,[7]]]], who to let every element in it plus 1?
 <jusss`> make (+1) work on every elemement on this list?
 <Cale> crestfallen: the contained function of type s -> (a,s) (or (s,a))
 <Cale> jusss`: That's not a valid list, unless you have some way to interpret 6 as being of the same type as [7]
 <Cale> (so you'd need a way to interpret numbers as lists, which I suppose you could have via a Num instance)
 <crestfallen> I think some members didn't like the name st , is that truly a bad name? 
 <crestfallen> I feel that I agree
 <ChaiTRex> jusss`: Usually.
 <jusss`> but that should be valid in dynamic languages like python
 <Cale> crestfallen: It wouldn't be a terrible name except there's already something else called ST in Haskell, it's a similar but different thing
 <Cale> jusss`: All the elements of a Haskell list must have the same type
 <Cale> jusss`: If we want a tree, we'λ  use a tree data type
 <jusss`> Cale: like that binary tree?
 <jusss`> can this list turn to a tree, and how to solve it?
 <Cale> For example,  data Tree a = Branch a [Tree a]
 <Cale> Or perhaps we should go with something like
 <Cale> data Tree a = Nil | Cons a (Tree a) | Subtree (Tree a) (Tree a)
 <Cale> Then we can encode your nested thing like:
 <Cale> Cons 1 (Cons 2 (Subtree (Cons 3 (Cons 4 Nil)) (Subtree (Cons 3 (Subtree (Cons 5 (Cons 6 (Subtree (Cons 7 Nil) Nil))) Nil)) Nil)))
 <Cale> You can check the parens for me :P
 <jusss`> right
 <Cale> We can write a function which applies a function to all the elements of such a thing
 <Cale> and in fact, while we're at it, might as well make it a Functor instance :)
 <Cale> instance Functor Tree where
 <Cale>   fmap f = g
 <Cale>     where
 <Cale>       g Nil = Nil
 <Cale>       g (Cons x t) = Cons (f x) (g t)
 <Cale>       g (Subtree t t') = Subtree (g t) (g t')
 <crestfallen> ok thanks, the way we did state with get, put and return, what distinguishes that from the ST approach?
 <Cale> crestfallen: You mean the approach in Hutton's book?
 <Cale> I believe Hutton eventually gets to get and put and return
 <Cale> If not, that's really strange
 <crestfallen> is it a subtlety, or is it how things are named that is the main difference?  yeah, in the hutton book
 <Cale> How things are named is pretty much the only difference
 <Cale> I didn't like his names, so my explanation doesn't use them
 <Cale> (especially "app")
 <crestfallen> yes thank you, the names I feel have been killing me. I just don't understand them
 <crestfallen> thanks a lot Cale  ,  I'm getting there. I want to resolve the name issue and see if it gets more clear
 <crestfallen> also I'm still staring at these two functions evalState and execState. they seem close to what we were doing with put and return   Cale
 <crestfallen> evalState :: s a -> s -> a
 <crestfallen> execState :: State s a -> s -> s
 <crestfallen> did I get that right?
 <Cale> evalState and execState are just the two halves of runState
 <ChaiTRex> crestfallen: s a is probably an invalid type.
 <Cale> runState produces a pair
 <Cale> That as well
 <Cale> That should be State s a
 <crestfallen> yeah thanks.. the 2 halves of runState ?
 <crestfallen> yeah ok copy that!
 <crestfallen> thanks kindly Cale.. plenty to work on
 <Cale> runState :: State s a -> s -> (s,a)
 <Cale> evalState is just that, except that it takes the 'a' part of the pair
 <Cale> and execState as well, but it gives you the 's' part of the pair
 <crestfallen> excellent, glad to know that, thanks
 <Cale> These things decompose State actions, while get, put and return either are or produce State actions
