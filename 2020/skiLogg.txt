Oct 21 16:57:53 <crestfallen> I thought the at the machine/math level, the 'container' took on additional structure
Oct 21 16:58:16 <ski> some of the things that you said sound confused, or at least strange
Oct 21 16:58:58 <ski> (at least from the point of view of an external observer, there needn't be much difference between those two things)
Oct 21 16:59:11 <crestfallen> as in 'an algebraic object has structure'
Oct 21 16:59:23 <ski> if you talk about e.g. `Maybe', then it's very simple
Oct 21 16:59:55 <ski> the effect allows "absense of a value/result". non-effect in this case is presence
Oct 21 17:00:27 <ski> in the case list `[]' (so lists), being effectful means having zero, or more than one result, in the list. non-effect means having just one result
Oct 21 17:01:37 <ski> in the case of `State s'. effectful means that the result may depend on the input state, and/or the output state may change (be different from the input state), or both. non-effect means that the input state is the same as the output state, and the result doesn't depend on the state
Oct 21 17:01:40 <crestfallen> does that mean Nothing is an Effect?
Oct 21 17:01:45 <ski> yes
Oct 21 17:02:36 <crestfallen> reading...
Oct 21 17:03:14 <ski> to get a better understanding of the (elusive) thing we mean, when we say "effect", and what sequencing in a monad (or in an idiom) means, you should get quite familiar with basic examples like `Maybe',`Either e',`[]',`Writer w',`Reader r',`State s',`Cont o'
Oct 21 17:03:36 <crestfallen> so Just has 'presence', it holds something , so it is non-effectual
Oct 21 17:03:37 <ski> then you can consider combinations of these basic patterns. that is monad transformers
Oct 21 17:03:56 <ski> and you can also consider specific applications, like parsers
Oct 21 17:05:06 <ski> any deviation, in an action (a value of type `m a'), from "just (deterministically) computing a single value of type `a' (independently of context)", is an effect
Oct 21 17:05:23 <crestfallen>  non-effect in this case is presence " 
Oct 21 17:05:46 <crestfallen> but some monads , where there is presence, could have effects too, right?
Oct 21 17:06:10 <ski> note that, commonly, when we say "effectful", we really mean "possibly effectful". so this sense of "effectful" contains "non-effectful" as a special case
Oct 21 17:06:24 <ski> if you want to exclude it, you could perhaps say "properly effectful"
Oct 21 17:06:38 <ski> and then, in the list case, a singleton list is not properly effectful
Oct 21 17:07:34 <crestfallen> so m a (Nothing is not (m a) because there is no type contained therein) is by nature a deviation, an effect.
Oct 21 17:07:55 <ski> if you have `m a'. and then add another `m' layer, with `pure'/`return' (either outside the existing `m' layer, or inside it), so that you get `m (m a)'. if you then use `join', to collapse those two layers, you get back the same action of type `m a' that you started with
Oct 21 17:08:35 <ski> that is, introducing a "dummy" `m' layer, that is non-effectful, and then combining ("smashing") it together with the other `m' layer, using `join', gets you back where you started
Oct 21 17:08:36 <crestfallen> right, so it hasn't taken on additional 'deviation'?
Oct 21 17:08:48 <ski> "do X, then do nothing" is the same as just "do X"
Oct 21 17:09:00 <ski> "do nothing, then do X" is also the same as just "do X"
Oct 21 17:09:09 <crestfallen> one sec
Oct 21 17:09:24 <ski> > pure [0,1,2,3] :: [] ([] Integer)
Oct 21 17:09:26 <lambdabot>  [[0,1,2,3]]
Oct 21 17:09:30 <ski> > join (pure [0,1,2,3] :: [] ([] Integer))
Oct 21 17:09:31 <lambdabot>  [0,1,2,3]
Oct 21 17:09:39 <ski> we're back where we started
Oct 21 17:09:46 <ski> > fmap pure [0,1,2,3] :: [] ([] Integer)
Oct 21 17:09:48 <lambdabot>  [[0],[1],[2],[3]]
Oct 21 17:09:52 <ski> > join (fmap pure [0,1,2,3] :: [] ([] Integer))
Oct 21 17:09:54 <lambdabot>  [0,1,2,3]
Oct 21 17:10:00 <ski> again, we're back where we started
Oct 21 17:10:02 <crestfallen> right so you would say there, there's no deviation of the structure?
Oct 21 17:10:13 <ski> `join', for lists, is just concatenation of a list of lists
Oct 21 17:10:19 <crestfallen> understood
Oct 21 17:10:26 <crestfallen> ..
Oct 21 17:10:37 <crestfallen> I'm reading above :)
Oct 21 17:10:37 <ski> putting a list as the single element of a wrapping list, and then concatenating, gives back the original list
Oct 21 17:10:57 <ski> also, wrapping each element in a singleton list, and then concatenating, also gives back the original list
Oct 21 17:11:17 <ski> so, in this sense, "singleton list" is "non-effectful"
Oct 21 17:11:35 <ski> for `Maybe', `Just' is similarly non-effectful
Oct 21 17:11:48 <crestfallen> > join [[1],[2]]
Oct 21 17:11:50 <lambdabot>  [1,2]
Oct 21 17:12:03 <ski> @where AAM
Oct 21 17:12:03 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
Oct 21 17:12:13 <ski> did you ever check out that one ^ ?
Oct 21 17:12:27 <ski> @where Typeclassopedia
Oct 21 17:12:27 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
Oct 21 17:12:32 <ski> could possibly also be useful
Oct 21 17:12:53 <ski> both should walk you through basic monads, making you more familiar with them
Oct 21 17:13:04 <crestfallen> yeah I've been looking. but I could have been getting confused by some cat theory reading
Oct 21 17:13:36 <crestfallen> if you have time, I need to read everything you wrote 10 minutes ago :)
Oct 21 17:16:59 <crestfallen> yeah man at the type level I understand join. (m a) is better than m(m a) because effects are minimized
Oct 21 17:17:57 <crestfallen> so unifying >>= with a simple function other than id would be a good exercise I believe
Oct 21 17:20:57 <ski> sometimes it may be nicer to think of `(=<<)', rather than `(>>=)'
Oct 21 17:21:14 <ski>   (=<<) :: (a -> M b) -> (M a -> M b)
Oct 21 17:21:41 <ski> it converts a function from `a' to `M b', to one that takes an `M a' and gives an `M b'
Oct 21 17:21:45 <ski> this means that if we have
Oct 21 17:21:51 <ski>   f :: a -> M b
Oct 21 17:21:52 <ski> and
Oct 21 17:21:58 <ski>   g :: b -> M c
Oct 21 17:22:16 <ski> we can't compose them as `g . f :: a -> M c' -- this is type incorrect
Oct 21 17:22:38 <ski> but we can call `(=<<)' on `g', like so :
Oct 21 17:22:53 <ski>   (g =<<) :: M b -> M c
Oct 21 17:23:05 <ski> (`(g =<<)' is the same as `(=<<) g')
Oct 21 17:23:14 <ski> and now we can compose this with `f' as :
Oct 21 17:23:27 <ski>   (g =<<) . f :: a -> M c
Oct 21 17:24:03 <ski> (this is very closely related to what `(<=<)'/`(>=>)' does)
Oct 21 17:24:41 <crestfallen> yeah I saw this somewhere thanks...
Oct 21 17:25:50 <crestfallen> but its funny , I came on to ask if >>= is essentially >=> with join extending it, and I got a lot of flack. then you came on and said, yes that's correct, in so many words...
Oct 21 17:27:08 <crestfallen> that little snippet from bartosz helped me see the issue, when the types try to resolve without join:
Oct 21 17:27:42 <crestfallen> https://termbin.com/xnxfu
Oct 21 17:29:52 <crestfallen> the resolution here:
Oct 21 17:29:54 <crestfallen> https://termbin.com/rp7e
Oct 21 17:31:00 <crestfallen> so, at least generally, between that and (>>= id) I am getting (>>=) at the type level.
Oct 21 17:34:10 <crestfallen> THANKS ski .. any snow where you stay yet?
Oct 21 17:40:05 <ski> ">>= is essentially >=> with join extending it" -- not quite
Oct 21 17:40:19 <ski> the relation between `>>=' and `>=>' is
Oct 21 17:40:28 <ski>   (f >=> g) x = f x >>= g
Oct 21 17:40:49 <ski> on the one hand, and
Oct 21 17:41:03 <ski>   mx >>= f = (\() -> mx) >=> g
Oct 21 17:41:06 <ski> on the other hand
Oct 21 17:41:47 <ski> so, no extra `join' in here. apart from the one that could be said to already be present, in `>>='/`>=>'. that is
Oct 21 17:41:59 <ski>   mx >>= f = join (fmap f mx)
Oct 21 17:42:38 <ski>   f >=> g = join . fmap g . f
Oct 21 17:43:03 <ski>   (f >=> g) x = join (fmap g (f x))  -- same thing, just expressed without composition
Oct 21 17:43:14 <ski> and no .. no snow here
Oct 21 17:44:04 <crestfallen> yes I think I can work out the distinction. I'm moving closer to this. I woke up this morning thinking about general notions of 'additional structure'
Oct 21 17:44:52 <crestfallen> monochro*m said that it's better to use bind than do notation. do you agree?
Oct 21 17:45:31 <ski> when trying to understand what's happening, how monads work, i think it's good to not focus too much on `do'
Oct 21 17:45:55 <ski> `do' is a convenient sugar, which makes things look a little bit more pretty
Oct 21 17:46:22 <crestfallen> interesting. yeah I like operators, I'll stick with (>>=) presently. thanks a lot I need to mosey
Oct 21 17:46:34 <ski> but, it can also make it seem more magical than it really is
Oct 21 17:46:43 <crestfallen> operators can?
Oct 21 17:46:50 <crestfallen> or do
Oct 21 17:46:55 <ski> this is also a reason why i think it's good to really dive into the particular monads, to understand them well
Oct 21 17:47:16 <ski> if you do that, i think you'll have a better chance of understanding the abstract concept, then
Oct 21 17:47:36 <crestfallen> so if I were to unify another function, other than id with (>>=) , what would suggest as an exercise?
Oct 21 17:47:51 <ski> first concrete, then abstract. don't try to tackle the abstract too early. it's hard, without having enough working experience with the concrete cases
Oct 21 17:48:09 <ski> `do' can make it seem more magical than it really is, i meant
Oct 21 17:48:46 <ski> hm
Oct 21 17:49:16 <crestfallen> 'do' can , ok yeah.      that's odd... I like the abstract..the type level really has my attention.
Oct 21 17:49:24 <ski> perhaps you could try to work out the types of `cross mx my = mx >>= \x -> my >>= \y -> return (x,y)'
Oct 21 17:49:41 <crestfallen> cross is a function?
Oct 21 17:49:51 <ski> yes, i just defined it
Oct 21 17:50:14 <crestfallen> wow ok. hey one more thing...
Oct 21 17:50:20 <ski> > let cross mx my = mx >>= \x -> my >>= \y -> return (x,y) in cross [0,1,2] [3,4]
Oct 21 17:50:23 <lambdabot>  [(0,3),(0,4),(1,3),(1,4),(2,3),(2,4)]
Oct 21 17:50:33 <ski> is an example of what it can do (in the list monad case)
Oct 21 17:51:40 <crestfallen> this looked interesting on continuations (don't know them yet): 
Oct 21 17:51:41 <crestfallen> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
Oct 21 17:52:50 <crestfallen> so that is like indeterminism, your example
Oct 21 17:53:14 <ski> continuations may be the hardest (at least of the "basic building block") monads, to understand
Oct 21 17:53:41 <crestfallen> yeah I followed that tutorial for a while..
Oct 21 17:53:42 <ski> list monad expresses nondeterminism, one can say, yes
Oct 21 17:54:00 <ski> ("angelic nondeterminism", to be specific. there's also "demonic" and "erratic")
Oct 21 17:54:24 <crestfallen> angelic? for the end times :)
Oct 21 17:54:47 <ski> that is, it expresses possibly having multiple different answers (each element of the list is a possible answer/solution)
Oct 21 17:55:03 <crestfallen> ski thanks kindly I need to meet someone. catch you soon?
Oct 21 17:55:30 <ski> "angelic" refers to that it's "helpful", if you end up in a dead-end, you'll automatically backtrack, and try the next alternative, at the last place there was a choice
Oct 21 17:55:48 <ski> maybe
Oct 21 17:56:02 <crestfallen> maybe?
Oct 21 17:57:46 <ski> i mean, i don't know whether we'll cross paths soon or not
Oct 21 17:58:00 <hekkaidekapus> crestfallen: Regarding ski’s examples, you could also try lambdabot.
Oct 21 17:58:28 <hekkaidekapus> @pl cross mx my = mx >>= \x -> my >>= \y -> return (x,y)
Oct 21 17:58:28 <lambdabot> cross = liftM2 (,)
Oct 21 17:58:40 <ski> heh
Oct 21 17:58:43 <hekkaidekapus> @undo do {x <- mx; y <- my; pure (x,y)}
Oct 21 17:58:43 <lambdabot> mx >>= \ x -> my >>= \ y -> pure (x, y)
Oct 21 17:58:47 <crestfallen> ok, well I hope you're well and healthy. thanks
Oct 21 17:58:50 <crestfallen> ski
Oct 21 17:59:01 <crestfallen> thanks hekkaidekapus I gotta go..
Oct 21 17:59:11 <ski> the point was to follow the type checking/inference of `cross mx my = mx >>= \x -> my >>= \y -> return (x,y)', specifically, through
Oct 21 17:59:40 <crestfallen> I'm on it.
